---
title: "Hands-On Exercise 3/ In-Class Exercise 3"
author: "KB"
editor: visual
format: html
execute: 
  warning: false
---

Updated on: 13-Dec-2022

(First published on: 2-Dec-2022)

# 5  Geographical Segmentation with Spatially Constrained Clustering Techniques

## 5.1 Overview

In this hands-on exercise, we will learn how to delineate homogeneous regions by using geographically referenced multivariate data.

There are two major analysis, namely:

-   hierarchical cluster analysis; and

-   spatially constrained cluster analysis.

### 5.1.1 Learning outcomes

By the end of this hands-on exercise, we will be able to:

-   convert GIS polygon data into R's simple feature (sf) data.frame by using appropriate functions of sf package;

-   convert sf data.frame into R's SpatialPolygonDataFrame object by using appropriate sf of package;

-   perform custer analysis by using `hclust()` of Base R;

-   perform spatially constrained cluster analysis using `skater()` of Base R; and

-   to visualise the analysis outputs by using ggplot2 and tmap package

## 5.2 Getting started

### 5.2.1 The analytical question

In this hands-on exercise, we are interested to delineate [Shan State](https://en.wikipedia.org/wiki/Shan_State), [Myanmar](https://en.wikipedia.org/wiki/Myanmar) into homogeneous regions by using multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.

## 5.3 The data

The 2 data sets used in this exercise are:

-   Myanmar Township Boundary Data (i.e. *myanmar_township_boundaries*) : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.

-   *Shan-ICT.csv*: This is an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.

Both data sets are download from [Myanmar Information Management Unit (MIMU)](http://themimu.info/)

### 5.3.1 Installing and loading R packages

Before we get started, it is important for us to install the necessary R packages into R and launch these R packages into R environment.

The R packages needed for this exercise are as follows:

-   Spatial data handling - sf, rgdal and spdep

-   Attribute data handling - tidyverse, especially readr, ggplot2 and dplyr

-   Choropleth mapping - tmap

-   Multivariate data visualisation and analysis - corrplot, ggpubr, GGally and heatmaply

-   Cluster analysis - cluster, and ClustGeo

The code chunk below installs and launches these R packages into R environment.

```{r}
pacman::p_load(rgdal, spdep, tmap, sf, 
               ggpubr, cluster, factoextra, NbClust, GGally,
               heatmaply, corrplot, psych, tidyverse, ClustGeo)
```

## 5.4 Data Import and Prepatation

### 5.4.1 Importing geospatial data into R environment

The Myanmar Township Boundary GIS data is in ESRI shapefile format. It will be imported into R environment by using the `st_read()` function of sf.

The code chunk used is shown below:

```{r}
#| eval: true
#| echo: true
shan_sf <- st_read(dsn = "Hands-On_Ex3/data/geospatial", 
                   layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) %>%
  select(c(2:7))
```

The imported township boundary object is called *shan_sf*. It is saved in simple feature data.frame format. We can view the content of the newly created *shan_sf* simple features data.frame by using the code chunk below.

```{r}
shan_sf
```

Notice that sf.data.frame conforms to Hardy Wickham's [tidy](https://edzer.github.io/rstudio_conf/#1) framework. Since *shan_sf* is conformed to tidy framework, we can also `glimpse()` to reveal the data type of it's fields.

```{r}
glimpse(shan_sf)
```

### 5.4.2 Importing aspatial data into R environment

The csv file will be import using `read_csv()` of readr package.

The code chunk used is shown below:

```{r}
ict <- read_csv ("Hands-On_Ex3/data/aspatial/Shan-ICT.csv", show_col_types = FALSE)
```

The attribute data set is called *ict*. It is saved in R's \* tibble data.frame\* format.

The code chunk below reveals the summary statistics of *ict* data.frame.

```{r}
summary(ict)
```

### **5.4.3 Derive new variables using dplyr package**

The unit of measurement of the values is the number of households. Using such a measure directly will bias townships with smaller number of households which also means there are fewer households owning radio, TV, etc.

In order to overcome this problem, we will derive the penetration rate of each ICT variable by using the code chunk below.

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*100) %>%
  mutate(`TV_PR` = `Television`/`Total households`*100) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*100) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*100) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*100) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*100) %>%
  # rename some of the columns to match them to those used in the shapefile
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

6 new fields have been added into the data.frame. They are RADIO_PR, TV_PR, LLPHONE_PR, MPHONE_PR, COMPUTER_PR, and INTERNET_PR.

Let us review the summary statistics of the newly derived penetration rates using the code chunk below.

```{r}
summary(ict_derived)
```

## 5.5 Exploratory Data Analysis (EDA)

### 5.5.1 EDA using statistical graphics

We can plot the distribution of the variables (i.e. Number of households with radio) by using appropriate Exploratory Data Analysis (EDA) as shown in the code chunk below.

Histogram is useful to identify the overall distribution of the data values (i.e. left skew, right skew or normal distribution)

```{r, fig.width=4,fig.height=3}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") + 
  ggtitle("Distribution of Households with radio")
```

Boxplot is useful to detect if there are outliers in the data.

```{r, fig.width=4,fig.heig}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_boxplot(color="black", 
               fill="light blue") + 
  ggtitle("Distribution of Househodls with radio (Boxplot)")
```

Next, we also plot the distribution of the newly derived variables (i.e. Radio penetration rate) by using the code chunk below.

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") + 
  ggtitle("Distribution of Radio Penetration Rate")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_boxplot(color="black", 
               fill="light blue") + 
  ggtitle("Distribution of Radio Penetration Rate \n(Boxplot)")
```

+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| *What can you observe from the distributions reveal in the histogram and boxplot?*                                                                                                          |
|                                                                                                                                                                                             |
| Reply: The distribution of the Radio Penetration Rate appears less skewed than the distribution of households with radio. From the boxplot, the number of outliers has reduced from 3 to 1. |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

In the next code chunk below, multiple histograms are plotted to reveal the distribution of the selected variables in the *ict_derived* data.frame.

-   Step 1: We create the individual histograms using the code chunk below.

-   Step 2: We use the the `ggarange()` function of [ggpubr](https://rpkgs.datanovia.com/ggpubr/) package to group these histograms together

```{r}
# Step 1
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

# Step 2

ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```

### 5.5.2 EDA using choropleth map

#### 5.5.2.1 Joining geospatial data with aspatial data

Before we prepare the choropleth map, we need to combine both the geospatial data object (i.e. *shan_sf*) and aspatial data.frame object (i.e. *ict_derived*) into one. This will be performed by using the [*left_join*](https://dplyr.tidyverse.org/reference/join.tbl_df.html) function of **dplyr** package. The *shan_sf* simple feature data.frame will be used as the base data object and the *ict_derived* data.frame will be used as the join table.

The code chunks below is used to perform the task. The unique identifier used to join both data objects is *TS_PCODE*.

```{r}
# if we want to retain the spatial data, the geospatial data file should be the left file. In this case, it's the shan_sf sf file.
shan_sf_joined <- left_join(shan_sf, 
                     ict_derived, by=c("TS_PCODE"="TS_PCODE"))
```

::: callout-note
## There is no new output data been created. Instead, the data fields from ict_derived data frame are now updated into the data frame of shan_sf.
:::

#### 5.5.2.2 Preparing a choropleth map

For a quick look at the distribution of Radio penetration rate of Shan State at township level, a choropleth map is prepared.

The code chunk below is used to prepare the choroplethby using the *qtm()* function of tmap package.

```{r}
qtm(shan_sf_joined, "RADIO_PR") +
  tm_layout(main.title = "Radio Penetration Rate",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.30, 
            legend.width = 0.30)
```

To demonstrate that the distribution shown in the choropleth map above are bias to the underlying total number of households at the townships, we create two choropleth maps, one for the total number of households (i.e. TT_HOUSEHOLDS.map) and one for the total number of household with Radio (RADIO.map) by using the code chunk below.

```{r}
TT_HOUSEHOLDS.map <- tm_shape(shan_sf_joined) + 
  tm_fill(col = "TT_HOUSEHOLDS",
          n = 5,
          style = "jenks", 
          title = "Total households") + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Total number of households",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.30, 
            legend.width = 0.30)

RADIO.map <- tm_shape(shan_sf_joined) + 
  tm_fill(col = "RADIO",
          n = 5,
          style = "jenks",
          title = "Households with radio") + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Number of households with radio",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.30, 
            legend.width = 0.30)

tmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,
             asp=NA, ncol=2)
```

Notice that the choropleth maps above clearly show that townships with relatively larger number of households are also showing relatively higher number of radio ownership.

Now let us plot the choropleth maps showing the distribution of Number of households with radios and Radio penetration rate by using the code chunk below.

```{r}
tm_shape(shan_sf_joined) +
    tm_polygons(c("RADIO", "RADIO_PR"),
                style="jenks") +
    tm_facets(sync = TRUE, ncol = 2) +
    tm_legend(legend.position = c("right", "bottom"))+
    tm_layout(title = c("Number of households with radio","Radio Penetration Rate"),
              outer.margins=0, asp=0)
```

+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| *Can you identify the differences?*                                                                                                                                                                  |
|                                                                                                                                                                                                      |
| From the 2 plots above, it is evident that regions with highest number of households in radios (on the left map) does not necessarily have the highest radio ownership rate (based on the right map) |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

## 5.6 Correlation Analysis

Before we perform cluster analysis, it is important for us to ensure that the cluster variables are not highly correlated.

In this section, we use [*corrplot.mixed()*](https://cran.r-project.org/web/packages/corrplot/corrplot.pdf) function of [**corrplot**](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html) package to visualise and analyse the correlation of the input variables.

```{r}
# Only select columns 12 to 16 from the data.frame
cluster_vars.cor = cor(ict_derived[,12:17])

corrplot.mixed(cluster_vars.cor,
               lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

The correlation plot above shows that COMPUTER_PR and INTERNET_PR are highly correlated. This suggest that only one of them should be used in the cluster analysis instead of both.

## 5.7 Hierarchy Cluster Analysis

In this section, we learn how to perform hierarchical cluster analysis. The analysis consists of four major steps:

### 5.7.1 Extract clustering variables

The code chunk below extracts the clustering variables from the *shan_sf_joined* simple feature object into data.frame.

```{r}
cluster_vars <- shan_sf_joined %>%
  # The st_set_geometry is to remove the geomerty data from the final output
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

::: callout-note
## The st_set_geometry() function removes the geometry information and converts the sf data.set to a data.frame.
:::

Notice that the final clustering variables list does not include variable INTERNET_PR because it is highly correlated with variable COMPUTER_PR.

Next, we set township name (*Ts.x* column) as the row names using the code chunk below so that the clustering algorithm won't use the township name for clustering.

```{r}
# Step 1: Assign the TS.x column as the row names of the cluster_var dataframe
row.names(cluster_vars) <- cluster_vars$"TS.x"

# Step 2:Exclude the TS.x coumn from the new shan_ict dataframe
shan_ict <- select(cluster_vars, c(2:6))

# Inspect the resultant dataframe
head(shan_ict)
```

### 5.7.2 Data Standardisation

In general, multiple variables will be used in cluster analysis. It is not unusual their values range are different. In order to avoid the cluster analysis result that leans towards clustering variables with large values, it is useful to standardise the input variables before performing cluster analysis.

#### 5.7.2.1 Min-Max standardisation

In the code chunk below, *normalize()* of [*heatmaply*](https://cran.r-project.org/web/packages/heatmaply/) package is used to stadardisation the clustering variables by using Min-Max method. The *summary()* is then used to display the summary statistics of the standardised clustering variables.

```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```

Notice that the values range of the Min-max standardised clustering variables are 0-1 now.

#### 5.7.2.2 Z-score standardisation

Z-score standardisation can be performed easily by using [*scale()*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/scale) of Base R. The code chunk below is used to stadardisation the clustering variables by using Z-score method.

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```

Notice the mean and standard deviation of the Z-score standardised clustering variables are 0 and 1 respectively.

::: callout-note
## describe() of psych package is used here instead of summary() of Base R because the former provides standard deviation.
:::

::: callout-warning
## Z-score standardisation method should only be used if we would assume all variables come from some normal distribution.
:::

#### 5.7.2.3 Visualise the standardised clustering variables

Beside reviewing the summary statistics of the standardised clustering variables, it is also a good practice to visualise their distribution graphical.

The code chunk below plot the scaled *Radio_PR* field.

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Radio_PR without \nstandardisation") +
  theme(plot.title = element_text(size=10,face="bold"))

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Radio_PR with \nMin-Max Standardisation") +
  theme(plot.title = element_text(size=10,face="bold"))

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Radio_PR with \nZ-score Standardisation") +
  theme(plot.title = element_text(size=10,face="bold"))

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

Notice that the overall distribution of the clustering variables will change after the data standardisation.

+----------------------------------------------------------------------------------------------+
| *What statistical conclusion can you draw from the histograms above?*                        |
|                                                                                              |
| Reply: Standardising the effect of making the distribution of the variable more symmetrical. |
+----------------------------------------------------------------------------------------------+

However, it is advisable **NOT** to perform data standardisation if the value range of the clustering variables are not vastly different

We can plot the density curve using the following code chunk.

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Raw values without \nstandardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Min-Max \nStandardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Z-score \nStandardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

### 5.7.3 Compute proximity matrix

In R, many packages provide functions to calculate distance matrix. We will compute the proximity matrix by using [*dist()*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/dist.html) of R.

*dist()* supports six distance proximity calculations, they are: **euclidean, maximum, manhattan, canberra, binary and minkowski**. The default is *euclidean* proximity matrix.

The code chunk below is used to compute the proximity matrix using *euclidean* method.

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
```

The code chunk below can then be used to list the content of *proxmat* for visual inspection.

```{r echo=TRUE}
proxmat
```

### 5.7.4 Computing hierarchical clustering

In R, there are several packages which provide hierarchical clustering function. In this hands-on exercise, [*`hclust()`*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/hclust.html) of R stats will be used.

*hclust()* employs agglomeration method to compute the cluster. Eight clustering algorithms are supported, they are: (i) ward.D, (ii) ward.D2, (iii) single, (iv) complete, (v) average(UPGMA), (vi) mcquitty(WPGMA), (vii) median(WPGMC) and (viii) centroid(UPGMC).

The code chunk below performs hierarchical cluster analysis using ward.D method. The hierarchical clustering output is stored in an object of class **hclust** which contains the tree produced by the clustering process.

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

We can then plot the tree by using `plot()` of R Graphics as shown in the code chunk below.

```{r}
plot(hclust_ward, cex = 0.6)
# cex is to scale down the plot to 60%, to prevent the township labels from overlapping
```

### 5.7.5 Selecting the optimal clustering algorithm

One of the challenge in performing hierarchical clustering is to identify stronger clustering structures. The issue can be solved by using use [*agnes()*](https://www.rdocumentation.org/packages/cluster/versions/2.1.0/topics/agnes) function of [**cluster**](https://cran.r-project.org/web/packages/cluster/) package. It functions like *hclus()*, however, with the *agnes()* function you can also get the agglomerative coefficient, which measures the amount of clustering structure found (values closer to 1 suggest strong clustering structure) by comparing the homogeneity within the clusters .

The code chunk below will be used to compute the agglomerative coefficients of 4 hierarchical clustering algorithms.

```{r}
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")

ac <- function(x) {
  agnes(shan_ict, method = x)$ac
}

map_dbl(m, ac)
```

From the output above, we can see that Ward's method provides the strongest clustering structure among the four methods assessed. Hence, in the subsequent analysis, only Ward's method will be used.

### **5.7.6 Determine the Optimal Clusters**

Another technical challenge face by data analyst in performing clustering analysis is to determine the optimal clusters to retain.

There are [three](https://www.datanovia.com/en/lessons/determining-the-optimal-number-of-clusters-3-must-know-methods/) commonly used methods to determine the optimal clusters, they are:

-   [Elbow Method](https://en.wikipedia.org/wiki/Elbow_method_(clustering))

-   [Average Silhouette Method](https://www.sciencedirect.com/science/article/pii/0377042787901257?via%3Dihub)

-   [Gap Statistic Method](https://statweb.stanford.edu/~gwalther/gap)

#### 5.7.6.1 Gap Statistic Method

The [**gap statistic**](http://www.web.stanford.edu/~hastie/Papers/gap.pdf) compares the total within intra-cluster variation for different values of k with their expected values under null reference distribution of the data. The estimate of the optimal clusters will be value that maximize the gap statistic (i.e., that yields the largest gap statistic). This means that the clustering structure is far away from the random uniform distribution of points.

To compute the gap statistic, [*`clusGap()`*](https://www.rdocumentation.org/packages/cluster/versions/2.1.0/topics/clusGap) of [**cluster**](https://cran.r-project.org/web/packages/cluster/) package will be used.

```{r}
set.seed(12345)
gap_stat <- clusGap(shan_ict, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 10, 
                    B = 50)

# K.max refers to the maximum number of clusters to consider, must be at least two.
# B refers to integer, number of Monte Carlo (“bootstrap”) samples.




# Print the result
print(gap_stat, method = "firstmax")
```

Also note that the [*`hcut`*](https://rpkgs.datanovia.com/factoextra/reference/hcut.html)*`()`* function used is from [**factoextra**](https://rpkgs.datanovia.com/factoextra/) package.

Next, we can visualise the plot by using [*`fviz_gap_stat()`*](https://rpkgs.datanovia.com/factoextra/reference/fviz_nbclust.html) of [**factoextra**](https://rpkgs.datanovia.com/factoextra/) package.

```{r}
fviz_gap_stat(gap_stat)
```

From the gap statistic graph above, the recommended number of cluster to retain is 1 or 2. However, it is not logical to retain only one or 2 clusters. Ideally, we should have 3 or more clusters. By examining the gap statistic graph, the 6-cluster gives the next largest gap statistic and should be the next best cluster number to pick.

::: callout-note
## In addition to these commonly used approaches, the [NbClust](https://cran.r-project.org/web/packages/NbClust/) package, published by Charrad et al., 2014, provides 30 indices for determining the relevant number of clusters and proposes to users the best clustering scheme from the different results obtained by varying all combinations of number of clusters, distance measures, and clustering methods.
:::

### 5.7.7 Interpret the dendrograms

In the dendrogram displayed above, each leaf corresponds to one observation. As we move up the tree, observations that are similar to each other are combined into branches, which are themselves fused at a higher height.

The height of the fusion, provided on the vertical axis, indicates the (dis)similarity between two observations. The higher the height of the fusion, the less similar the observations are. Note that, conclusions about the proximity of two observations can be drawn only based on the height where branches containing those two observations first are fused. We **cannot** use the proximity of two observations along the horizontal axis as a criteria for their similarity.

It's also possible to draw the dendrogram with a border around the selected clusters by using [*`rect.hclust()`*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/rect.hclust.html) of R stats. The argument *border* is used to specify the border colors for the rectangles.

```{r}
plot(hclust_ward, cex = 0.6)

# rect is to set the rectangles
rect.hclust(hclust_ward, 
            k = 6, 
            border = 2:7)
```

### 5.7.8 Visually-driven hierarchical clustering analysis

In this section, we learn how to perform visually-driven hiearchical clustering analysis by using [*heatmaply*](https://cran.r-project.org/web/packages/heatmaply/) package.

With heatmaply, we are able to build both highly interactive cluster heatmap or static cluster heatmap.

#### 5.7.8.1 Transforming the data frame into a matrix

The *shan_ict* data is currently loaded in a data frame.

The code chunk below is used to transform *shan_ict* data frame into a data matrix to generate the heatmap.

```{r}
shan_ict_mat <- data.matrix(shan_ict)
```

#### 5.7.8.2 Plot interactive cluster heatmap using *heatmaply()*

In the code chunk below, the [*`heatmaply()`*](https://talgalili.github.io/heatmaply/reference/heatmaply.html) of [heatmaply](https://talgalili.github.io/heatmaply/) package is used to build an interactive cluster heatmap.

```{r}
heatmaply(normalize(shan_ict_mat),
          Colv=NA,
          dist_method = "euclidean",
          hclust_method = "ward.D",
          seriate = "OLO",
          colors = Blues,
          k_row = 6,
          margins = c(NA,200,60,NA),
          fontsize_row = 5,
          fontsize_col = 5,
          main="Geographic Segmentation of Shan State by ICT indicators",
          xlab = "ICT Indicators",
          ylab = "Townships of Shan State"
          )
```

### 5.7.9 Map the clusters formed

With closed examination of the dendragram above, we have decided to retain six clusters.

[*`cutree()`*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/cutree.html) of R Base will be used in the code chunk below to derive a 6-cluster model.

```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

The output is called *groups*. It is a *list* object.

In order to visualise the clusters, the *groups* object need to be appended onto *shan_sf* simple feature object.

The code chunk below form the join in three steps:

-   the *groups* list object will be converted into a matrix;

-   *`cbind()`* is used to append *groups* matrix onto shan_sf to produce an output simple feature object called `shan_sf_cluster`; and

-   *`rename()`* of dplyr package is used to rename *as.matrix.groups* field as *CLUSTER*.

```{r}
shan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER`=`as.matrix.groups.`)
```

Next, *qtm()* of tmap package is used to plot the choropleth map showing the cluster formed.

```{r}
qtm(shan_sf_cluster, "CLUSTER") +
  tm_layout(main.title = "Hierarchical Cluster Map",
            main.title.position = "center",
            main.title.size = 1.2)
```

The choropleth map above reveals the clusters are very fragmented. The is one of the major limitation when non-spatial clustering algorithm such as hierarchical cluster analysis method is used.

## 5.8 Spatially Constrained Clustering - SKATER approach

In this section, we learn how to derive spatially constrained cluster by using [*`skater()`*](https://r-spatial.github.io/spdep/reference/skater.html) method of spdep package.

### 5.8.1 Converting into SpatialPolygonsDataFrame

First, we need to convert `shan_sf` into SpatialPolygonsDataFrame. This is because SKATER function only support sp objects such as SpatialPolygonDataFrame.

The code chunk below uses [*as_Spatial()*](https://r-spatial.github.io/sf/reference/coerce-methods.html) of sf package to convert *shan_sf* into a SpatialPolygonDataFrame called *shan_sp*.

```{r}
shan_sp <- as_Spatial(shan_sf)
```

### 5.8.2 Computing Neighbour List

Next, [`poly2nd()`](https://r-spatial.github.io/spdep/reference/poly2nb.html) of spdep package will be used to compute the neighbours list from polygon list.

```{r}
shan.nb <- poly2nb(shan_sp, queen = TRUE)
summary(shan.nb)
```

We plot the neighbors list on shan_sp by using the code chunk below. Since we now can plot the community area boundaries as well, we plot this graph on top of the map. The first plot command gives the boundaries. This is followed by the plot of the neighbor list object, with coordinates applied to the original SpatialPolygonDataFrame (Shan state township boundaries) to extract the centroids of the polygons. These are used as the nodes for the graph representation. We also set the color to blue and specify add=TRUE to plot the network on top of the boundaries.

```{r}
plot(shan_sp, 
     border=grey(.5))
plot(shan.nb, 
     coordinates(shan_sp), 
     col="blue", 
     add=TRUE)
title(main="Neighbor Network (Queen Contiguity)")
```

::: callout-note
## If we plot the network first and then the boundaries, some of the areas will be clipped. This is because the plotting area is determined by the characteristics of the first plot. In this example, because the boundary map extends further than the graph, we plot it first.
:::

### 5.8.3 Compute Minimum Spanning Tree (MST)

The MST is a graph that includes all the nodes in the network, but passes through each only once. So, it reduces the complexity of the original graph to one where each node is connected to only one other node. The resulting tree has n nodes and n-1 edges. The "minimum" part pertains to a cost function that is minimized. The objective is to minimize the overall length (or cost) of the tree. In its simplest form, the cost consists of the distances between the nodes. Here, however, a more general measure of cost is used in the form of the multivariate dissimilarity measure between each pair of nodes. This is based on a multivariate Euclidean distance between the standardized values for the variables, as was the case in the other clustering algorithms.

![](images/paste-EC021FFF.png){width="676"}

#### 5.8.3.1 Calculate edge costs

The first step in the process is to compute the costs associated with each edge in the neighbor list. In other words, for each observation, the dissimilarity is computed between it and each of its neighbors (as defined by the neighbor list). In the **spdep** package, this is carried out by the **nbcosts** function. Its arguments are the neighbor list and the standardized data frame.

Next, [*`nbcosts()`*](https://r-spatial.github.io/spdep/reference/nbcosts.html) of spdep package is used to compute the cost of each edge. It is the distance between 2 nodes, with reference to the provided attributes (in *shan_ict*). This function compute this distance using a data.frame with observations vector in each node.

The code chunk below is used to compute the cost of each edge.

```{r}
lcosts <- nbcosts(shan.nb, shan_ict)
```

For each observation, this gives the pairwise dissimilarity between its values on the five variables and the values for the neighbouring observation (from the neighbour list). Basically, this is the notion of a generalised weight for a spatial weights matrix.

Next, We will incorporate these costs into a weights object in the same way as we did in the calculation of inverse of distance weights. In other words, we convert the neighbour list to a list weights object by specifying the just computed *lcosts* as the weights.

In order to achieve this, [*nb2listw()*](https://r-spatial.github.io/spdep/reference/nb2listw.html) of spdep package is used as shown in the code chunk below.

Note that we specify the *style* as **B** to make sure the cost values are not row-standardised.

```{r}
shan.w <- nb2listw(shan.nb, 
                   lcosts, 
                   style="B")
summary(shan.w)
```

### 5.8.4 Compute the minimum spanning tree

The minimum spanning tree is computed by mean of the [*mstree()*](https://r-spatial.github.io/spdep/reference/mstree.html) of **spdep** package as shown in the code chunk below. The only required argument is the weights object. It summarizes the tree by giving each edge as the pair of connected nodes, followed by the cost associated with that edge.

```{r}
shan.mst <- mstree(shan.w)
```

After computing the MST, we can check its class and dimension by using the code chunk below.

```{r}
class(shan.mst)
```

```{r}
dim(shan.mst)
```

Note that the dimension is 54 and not 55. This is because the minimum spanning tree consists on n-1 edges (links) in order to traverse all the nodes.

We can display the content of *shan.mst* by using *head()* as shown in the code chunk below.

```{r}
head(shan.mst)
```

The plot method for the MST includes a way to show the observation numbers of the nodes in addition to the edge. As before, we plot this together with the township boundaries. We can see how the initial neighbor list is simplified to just one edge connecting each of the nodes, while passing through all the nodes.

```{r}
plot(shan_sp, border=gray(.5))
plot.mst(shan.mst, 
         coordinates(shan_sp), 
         col="blue", 
         cex.lab=0.7, 
         cex.circles=0.005, 
         add=TRUE)
title(main="Minimum Spanning Tree plot")
```

### 5.8.5 Compute spatially constrained clusters using SKATER method

The code chunk below computes the spatially constrained cluster using [*skater()*](https://r-spatial.github.io/spdep/reference/skater.html) of **spdep** package.

```{r}
clust6 <- skater(edges = shan.mst[,1:2], 
                 data = shan_ict, 
                 method = "euclidean", 
                 ncuts = 5)
```

The *`skater()`* takes three mandatory arguments: -

1.  The first two columns of the MST matrix (i.e. not the cost),

2.  The data matrix (to update the costs as units are being grouped), and

3.  The number of cuts.

Note: The number of cuts is set to **one less than the number of clusters**. So, the value specified is **not** the number of clusters, but the number of cuts in the graph, one less than the number of clusters.

The result of the *`skater()`* is an object of class **skater**. We can examine its contents by using the code chunk below.

```{r}
str(clust6)
```

The most interesting component of this list structure is the groups vector that contains the labels of the cluster to which each observation belongs (as before, the label itself is arbitrary). This is followed by a detailed summary for each cluster in the edges.groups list. Sum of squares measures are given as ssto for the total and ssw to show the effect of each cut on the overall criterion.

We can check the cluster assignment by using the code chunk below.

```{r}
ccs6 <- clust6$groups
ccs6
```

We can find out how many observations are in each cluster by means of the table command.

```{r}
table(ccs6)
```

Lastly, we can also plot the pruned tree that shows the six clusters on top of the townshop area.

```{r}
#| warning: false
plot(shan_sp, border=gray(.5))
plot(clust6, 
     coordinates(shan_sp), 
     cex.lab=.7,
     groups.colors=c("red","green","blue", "brown", "pink"),
     cex.circles=0.005, 
     add=TRUE)
title(main="Minimum Spanning Tree plot \n using Skater method", add=TRUE)
```

### 5.8.6 Visualise the clusters in choropleth map

The code chunk below is used to plot the newly derived clusters by using SKATER method.

```{r}
groups_mat <- as.matrix(clust6$groups)

# Join back to the sf data table for plotting. One pre-condition for just a combination is that we must not sort the dataframe in the earlier steps
shan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%
  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)

qtm(shan_sf_spatialcluster, "SP_CLUSTER") +
  tm_layout(main.title = "Hierarchical Cluster Map \nusing Skater method",
            main.title.position = "center",
            main.title.size = 1.2) 
```

For easy comparison, it will be better to place both the hierarchical clustering and spatially constrained hierarchical clustering maps next to each other.

```{r}
#| warning: false
hclust.map <- qtm(shan_sf_cluster,
                  "CLUSTER") + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Hierarchical Cluster Map \n ",
            main.title.position = "center",
            main.title.size = 1.2) 

shclust.map <- qtm(shan_sf_spatialcluster,
                   "SP_CLUSTER") + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Hierarchical Cluster Map \nusing Skater method",
            main.title.position = "center",
            main.title.size = 1.2) 

tmap_arrange(hclust.map, shclust.map,
             asp=NA, ncol=2)
```

## 5.9 Spatially Constrained Clustering: ClustGeo Method

In this section, you will gain hands-on experience on using functions provided by **ClustGeo** package to perform non-spatially constrained hierarchical cluster analysis and spatially constrained cluster analysis.

+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| A note on ClustGeo Package                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
+=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================+
| [**ClustGeo**](https://cran.r-project.org/web/packages/ClustGeo/) package is an R package specially designed to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called `hclustgeo()` including spatial/geographical constraints.                                                                                                                                                                                                                                                        |
|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| In the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between \[0, 1\]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the **attribute/clustering variable space**. D1, on the other hand, gives the dissimilarities in the **constraint space**. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1. |
|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| The idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called `choicealpha()`.                                                                                                                                                                                                                                                                                                                                           |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

### 5.9.1 Ward-like hierarchical clustering: ClustGeo

ClustGeo package provides function called `hclustgeo()` to perform a typical Ward-like hierarchical clustering just like `hclust()` you learned in previous section. This [only works]{.underline} with the Ward method.

To perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix as shown in the code chunk below.

```{r}
nongeo_cluster <- hclustgeo(proxmat)
plot(nongeo_cluster, cex = 0.5)
rect.hclust(nongeo_cluster, 
            k = 6, 
            border = 2:5)
```

Note that the dissimilarity matrix must be an object of class `dist`, i.e. an object obtained with the function `dist()`. For sample code chunk, please refer to 5.7.3 Computing proximity matrix

#### 5.9.1.1 Mapping the clusters formed

Similarly, we can plot the clusters on a categorical area shaded map by using the steps we learned in 5.7.9 Mapping the clusters formed.

```{r}
groups <- as.factor(cutree(nongeo_cluster, k=6))
```

```{r}
shan_sf_ngeo_cluster <- cbind(shan_sf_joined, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

```{r}
qtm(shan_sf_ngeo_cluster, "CLUSTER") + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "ClustGeo Cluster Map",
            main.title.position = "center",
            main.title.size = 1.2) 
```

### 5.9.2 Spatially Constrained Hierarchical Clustering

Before we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using [`st_distance()`](https://r-spatial.github.io/sf/reference/geos_measures.html) of sf package.

```{r}
dist <- st_distance(shan_sf, shan_sf)
distmat <- as.dist(dist)
```

Notice that `as.dist()` is used to convert the data frame into matrix.

Next, `choicealpha()` will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.

```{r}
cr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)
# the 0.1 in the range.alpha argument indicates that the break points should be at 0.1 interval
# To note that the argument name for number of clusters in in capital K
# graph = True is to plot the 2 graphs below
```

With reference to the graphs above, alpha = 0.3 will be used as shown in the code chunk below. This is derived with reference to the Standardised Chart (with y-axis Qnorm). It shows that about 0.6 (or 60%) of the geospatial data is reflected with only a 0.2 (or 20%) reduction in aspatial data.

```{r}
clustG <- hclustgeo(proxmat, distmat, alpha = 0.3)
```

Next, `cutree()` is used to derive the cluster objecct.

```{r}
groups <- as.factor(cutree(clustG, k=6))
```

We will then join back the group list with shan_sf polygon feature data frame by using the code chun below.

```{r}
shan_sf_Gcluster <- cbind(shan_sf_joined, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

We can now plot the map of the newly delineated spatially constrained clusters.

```{r}
qtm(shan_sf_Gcluster, "CLUSTER")  + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "ClustGeo Cluster Map \n(alpha = 0.3)",
            main.title.position = "center",
            main.title.size = 1.2) 
```

## 5.10 Visual Interpretation of Clusters

### 5.10.1 Visualise individual clustering variable

THe Code chunk below is used to check the distribution of the variable (i.e RADIO_PR) by cluster.

```{r}
ggplot(data = shan_sf_ngeo_cluster,
       aes(x = CLUSTER, y = RADIO_PR)) +
  geom_boxplot()+
  stat_summary(geom = "point",
               fun.y="mean",
               colour ="red",
               size=2) +
  ggtitle("Distribution of RADIO_PR by Cluser")
```

The boxplot shows that Cluster 3 displays the highest mean (red dot) Radio Ownership Per Thousand Household. This is followed by Cluster 2, 1, 4, 5 and 6.

### 5.10.2 Multivariate Visualisation

Past studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, [`ggparcoord()`](https://ggobi.github.io/ggally/reference/ggparcoord.html) of [**GGally**](https://ggobi.github.io/ggally/) package.

```{r}
ggparcoord(data = shan_sf_ngeo_cluster, 
           columns = c(17:21), 
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of ICT Variables by Cluster") +
  facet_grid(~ CLUSTER) + 
  theme(axis.text.x = element_text(angle = 90))
```

The parallel coordinate plot above shows that households in Cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in Cluster 5 tends to own the lowest of all the five ICT.

Note that the `scale` argument of `ggparcoor()` provide several methods to scale the clustering variables. They are:

-   std: univariately, subtract mean and divide by standard deviation.

-   robust: univariately, subtract median and divide by median absolute deviation.

-   uniminmax: univariately, scale so the minimum of the variable is zero, and the maximum is one.

-   globalminmax: no scaling is done; the range of the graphs is defined by the global minimum and the global maximum.

-   center: use uniminmax to standardize vertical height, then center each variable at a value specified by the scaleSummary param.

-   centerObs: use uniminmax to standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param

There is no one best scaling method to use. We should explore them and select the one that best meet our analysis need.

Last but not least, we can also compute the summary statistics such as mean, median, sd, etc to complement the visual interpretation.

In the code chunk below, `group_by()` and `summarise()` of dplyr are used to derive mean values of the clustering variables.

```{r}
shan_sf_ngeo_cluster %>% 
  st_set_geometry(NULL) %>%
  group_by(CLUSTER) %>%
  summarise(mean_RADIO_PR = mean(RADIO_PR),
            mean_TV_PR = mean(TV_PR),
            mean_LLPHONE_PR = mean(LLPHONE_PR),
            mean_MPHONE_PR = mean(MPHONE_PR),
            mean_COMPUTER_PR = mean(COMPUTER_PR))
```
