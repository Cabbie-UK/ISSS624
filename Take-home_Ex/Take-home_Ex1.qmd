---
title: "Take-home Exercise 1"
author: "KB"
editor: visual
---

![](images/paste-18F74B6F.png)

First published on:

# Geospatial Analytics for Social Good

1 Overview

## 1.1 Setting the Scene

Water is an important resource to mankind. Clean and accessible water is critical to human health. It provides a healthy environment, a sustainable economy, reduces poverty and ensures peace and security. Yet over 40% of the global population does not have access to sufficient clean water. By 2025, 1.8 billion people will be living in countries or regions with absolute water scarcity, according to UN-Water. The lack of water poses a major threat to several sectors, including food security. Agriculture uses about 70% of the world's accessible freshwater.

Developing countries are most affected by water shortages and poor water quality. Up to 80% of illnesses in the developing world are linked to inadequate water and sanitation. Despite technological advancement, providing clean water to the rural community is still a major development issue in many countries globally, especially in Africa.

To provide clean and sustainable water supply to the rural community, a global [Water Point Data Exchange (WPdx)](https://www.waterpointdata.org/about/) project was initiated. The main aim of this initiative is to collect water point related data from rural areas at the water point or small water scheme level and share the data via WPdx Data Repository, a cloud-based data library. The data is collected based on [WPDx Data Standard](https://www.waterpointdata.org/wp-content/uploads/2021/04/WPDx_Data_Standard.pdf).

1.2 Objectives

Geospatial analytics hold tremendous potential to address complex problems facing society.

In this study, we will apply appropriate global and local measures of spatial association techniques to reveal the spatial patterns of **non-functional** water points in Nigeria.

1.3 The Data

Geospatia data

For this assignment, 2 datasets will be used.

1.  geo_export: It contains information on the water points in Nigeria. The data is available from [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/) and we are using the WPdx+ data set. Download the data in shapefile format.

    ![](images/paste-D25947E2.png){width="598"}

2.  nga_lga2: The contains Nigeria Level-2 Administrative Boundary (also known as Local Government Area (LGA)) polygon features GIS data will be used. The data can be downloaded from The [Humanitarian Data Exchange](https://data.humdata.org/) portal

1.4 The Tasks

The specific tasks of this assignments are:

-   Using appropriate sf method, import the shapefiles into R and save it in a simple feature data frame format. The Projected Coordinate Systems of Nigeria, EPSG: 26391 is used

-   Using appropriate tidyr and dplyr methods, derive the proportion of functional and non-functional water point at LGA level.

-   Combining the geospatial data frames into a Simple Feature (`sf`) data frame.

-   Performing outliers/clusters analysis by using appropriate local measures of spatial association methods.

-   Performing hotspot areas analysis by using appropriate local measures of spatial association methods.

1.5 Thematic Mapping

-   Plot maps to show the spatial distribution of functional and non-functional water point rate at LGA level by using appropriate thematic mapping technique provided by tmap package.

1.6 Analytical Mapping

-   Plot hotspot areas and outliers/clusters maps of functional and non-functional water point rate at LGA level by using appropriate thematic mapping technique provided by tmap package.

2 Setup

2.1 Import and load relevant packages into R environment

The R packages we'll use for this analysis are:

-   **sf**: used for importing, managing, and processing geospatial data

-   **tidyverse**: a collection of packages for data manipulation, visualisation and other science related tasks

-   **tmap**: used for creating thematic maps, such as choropleth and bubble maps

-   **spdep**: used to create spatial weights matrix objects and related calculations (e.g.Â spatially lag attributes)

-   **funModeling**: a library for rapid Exploratory Data Analysis

```{r}
pacman::p_load(sf, tidyverse, tmap, spdep, funModeling)
```

2.2 Import the Geospatial data sets

2.2.1Import water point geospatial data

We import the geo_export shapefile using `st_read()` of sf library and use `filter()` of the dplyr package to extract water point records in Nigeria

```{r}
#| eval: false

wp = st_read(dsn = "Take-home_Ex1/geodata",
              layer = "geo_export",
              crs = 4326) %>%
  filter(clean_coun == "Nigeria")
```

::: callout-note
## We do not transform the geographic data at this point as we will be using `st_intersects()` in a later step to process the data. This is because st_intersects() only works correctly if the geospatial data are in geographic coordinate system (i.e. wgs84)
:::

Next, `write_rds()` of readr package is used to save the extracted sf data table (i.e. wp) into an output file in rds data format. The output file is called *wp_nga.rds* and it is saved in *geodata* sub-folder.

```{r}
#| eval: false

write_rds(wp, "Take-home_Ex1/geodata/wp_nga.rds")
```

2.2.1Import Nigeria LGA boundary data

We use `st_read()` to import the LGA boundary data into sf data table

```{r}
#| eval: false

nga = st_read(dsn = "Take-home_Ex1/geodata",
               layer = "nga_lga2",
               crs = 4326)
```

3 Data Wrangling

3.1 Recode the values in the status_cle column

The status_cle column in the *wp_nga.rds* file indicates the status of the water point when it was last assessed.

We do a count of the values in the status_cle column using `freq()` of the funModeling package.

```{r}
#| eval: false

wp_nga = read_rds("Take-home_Ex1/geodata/wp_nga.rds")

freq(data=wp_nga,input = 'status_cle')
```

![](images/paste-53B41B3C.png)

Given that our objective is to examine spatial patterns of **non-functional** water points in Nigeria, we need to first compute the total number of functional, non-functional and blank value (denoted by "NA") water points before we can derive the proportion of non-functional and functional water points.

To do so, we perform the following steps:

-   We use the replace_na() method to recode all the *NA* values in status_cle column into Unknown

    ```{r}
    #| eval: false

    wp_nga = wp_nga %>%
      mutate(status_cle = replace_na(status_cle, "Unknown"))
    ```

-   We use `filter()` of dplyr to create data tables which group (i) functional, (2) non functional and (3) water points with unknown status together

    ```{r}
    #| eval: false

    # Extract functional water points
    wpt_functional = wp_nga %>%
      filter(status_cle %in%
               c("Functional", 
                 "Functional but not in use",
                 "Functional but needs repair"))

    # Extract non-functional water points
    wpt_nonfunctional = wp_nga %>%
      filter(status_cle %in%
               c("Abandoned/Decommissioned", 
                 "Abandoned",
                 "Non-Functional",
                 "Non functional due to dry season",
                 "Non-Functional due to dry season"))

    # Extract water points with Unknown value
    wpt_unknown = wp_nga %>%
      filter(status_cle == "Unknown")
    ```

3.2 Perform Point-in-Polygon Count

We use st_intersects() of sf package to compute the number of functional, non-functional and unknown status water points in each LGA.

```{r}
#| eval: false

nga_wp = nga %>% 
  mutate(`total wpt` = lengths(
    st_intersects(nga, wp_nga))) %>%
  mutate(`wpt functional` = lengths(
    st_intersects(nga, wpt_functional))) %>%
  mutate(`wpt non-functional` = lengths(
    st_intersects(nga, wpt_nonfunctional))) %>%
  mutate(`wpt unknown` = lengths(
    st_intersects(nga, wpt_unknown)))
```

3.3 Save the data table for spatial analysis

We derive two fields namely *pct_functional* and *pct_non-functional* using the `mutate()` of **dplyr** package. To keep the file size small, we use `select()` of **dplyr** is used to retain only columns 3,4,9,10, 18,19,20,21,22,and 23.

```{r}
#| eval: false

nga_wp = nga_wp %>%
  mutate(pct_functional = `wpt functional`/`total wpt`) %>%
  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`) %>%
  select(3:4, 9:10, 18:23)
```

Thereafter ,we save the tidied sf data table into rds format for our spatial analysis

```{r}
#| eval: false

write_rds(nga_wp, "Take-home_Ex1/geodata/nga_wp.rds")
```

3.4 Visualise the spatial dsitribution of water points

```{r}
#| fig-width: 14
#| fig-height: 12

# Load the nga_wp sf data file prepare in the previous steps
nga_wp <- read_rds("Take-home_Ex1/geodata/nga_wp.rds")

# Plot the various types of water points
total = qtm(nga_wp, "total wpt") + 
        tm_layout(main.title = "Total no. of \nwater points",
                  main.title.position = "center",
                  main.title.size = 1.0,
                  legend.height = 0.26,
                  legend.width = 0.40) 

wp_functional = qtm(nga_wp, "wpt functional") + 
                tm_layout(main.title = "Total no. of functional \nwater points",
                  main.title.position = "center",
                  main.title.size = 1.0,
                  legend.height = 0.26,
                  legend.width = 0.40) 

wp_nonfunctional = qtm(nga_wp, "wpt non-functional") + 
                tm_layout(main.title = "Total no. of non-functional \nwater points",
                  main.title.position = "center",
                  main.title.size = 1.0,
                  legend.height = 0.26,
                  legend.width = 0.40)

unknown <- qtm(nga_wp, "wpt unknown") + 
                tm_layout(main.title = "Total no. of  water points \nwith unknown status",
                  main.title.position = "center",
                  main.title.size = 1.0,
                  legend.height = 0.26,
                  legend.width = 0.40)

tmap_arrange(total, wp_functional, wp_nonfunctional, unknown, ncol=2)
```

4 Global Spatial Autocorrelation

4.1.1 Compute Contiguity Spatial Weights using Queen contiguity

```{r}
wm_q = poly2nb(nga_wp,queen=TRUE)

summary(wm_q)
```

We have 1 LGA with no adjacent boundaries with other LGAs. This will be an issue when we derive the Moran's statistics. We consider using adaptive weights instead.

4.1.2 Row-standard weighs matrix

```{r}
set.ZeroPolicyOption(TRUE)
rswm_q <- nb2listw(wm_q, 
                   style="W")
print(rswm_q)
```

4.1.3 Maron's I Test

```{r}
moran.test(nga_wp$`pct_non-functional`, 
           listw=rswm_q, 
           zero.policy = TRUE, 
           na.action=na.omit)
```

Monte Carlo Moran's I

```{r}
set.seed(1234)
bperm= moran.mc(nga_wp$`pct_non-functional`, 
                listw=rswm_q, 
                nsim=999, 
                zero.policy = TRUE, 
                na.action=na.omit)
bper
```

Visualise Monte Carlo Moran's I

```{r}
hist(bperm$res, 
     freq=TRUE, 
     breaks=20, 
     xlab="Simulated Moran's I")
abline(v=0.46319, 
       col="red") 
```

Indication of clustering at with a +ve Moran's I statistic. This statistic is significant given that p-value is \< 0.05

Plot Moran's I correlogram

```{r}
MI_corr <- sp.correlogram(wm_q, 
                          nga_wp$`pct_non-functional`, 
                          order=6, 
                          method="I", 
                          style="W")
plot(MI_corr)
```

Compute local Moran's I

```{r}
localMI <- localmoran(nga_wp$`pct_non-functional`, rswm_q, zero.policy = TRUE, na.action = na.exclude)
head(localMI)
```

Map local Moran's I to dataframe

```{r}
nga_wp.localMI <- cbind(nga_wp,localMI) %>%
  rename(Pr.Ii = Pr.z....E.Ii..)
```

Plot local Moran's I values

```{r}
tm_shape(nga_wp.localMI) +
  tm_fill(col = "Ii", 
          style = "pretty",
          palette = "RdBu",
          title = "local moran statistics") +
  tm_borders(alpha = 0.5)
```

local Moran's I p-values

```{r}
tm_shape(nga_wp.localMI) +
  tm_fill(col = "Pr.Ii", 
          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
          palette="-Blues", 
          title = "local Moran's I p-values") +
  tm_borders(alpha = 0.5)
```

Moran scatterplot

```{r}

```
