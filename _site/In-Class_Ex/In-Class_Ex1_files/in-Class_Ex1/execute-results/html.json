{
  "hash": "a76009ce3061234e636ab1ebd4399285",
  "result": {
    "markdown": "---\ntitle: \"In-Class Exercise 1\"\nauthor: \"KB_Kwa\"\neditor: visual\n---\n\n\nSpatial Weights and Applications\n\n3.1 Overview\n\nLearn how to:\n\n1.  Compute spatial weights\n\n2.  Calculate spatial lagged variables\n\nusing appropriate functions of spdep package.\n\n(Note: this above was part of an in-class exercise for ISSS624 conducted on 19 Nov 2022).\n\n3.2 Data available\n\nTwo datasets are used in this exercise. They are:\n\n1.  Hunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\n\n2.  Hunan_2012.csv: This csv file contains selected Hunan's local development indicators in 2012.\n\n3.3 Getting Started\n\nThe code chunks below will install and load the 4 packages needed for this exericse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse, spdep, tmap) # wrapper for install and load library\n```\n:::\n\n\n3.4 Import data into R for analysis\n\n3.4.1 Import shapefile whch contains Hunan county boundary layer\n\nThe code chunk below will import ESRI shapefile into R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan = st_read(dsn = \"In-class_Ex01/data/geospatial\", \n                  layer = \"hunan\") # The dsn path is with reference to the .qmd document created to house this page\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `hunan' from data source \n  `C:\\Cabbie-UK\\ISSS624\\In-Class_Ex\\In-Class_Ex1\\In-class_Ex01\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\n3.4.2 Import attribute data from csv file\n\nWe import *Hunan_2012.csv* into R by using *read_csv()* of **readr** package. The output is R dataframe class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 = read_csv(\"In-class_Ex01/data/aspatial/Hunan_2012.csv\", show_col_types = FALSE) \n```\n:::\n\n\nInspect the first rows of hunan2012\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan2012)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 29\n  County   City  avg_w…¹ depos…²   FAI Gov_Rev Gov_Exp    GDP GDPPC    GIO  Loan\n  <chr>    <chr>   <dbl>   <dbl> <dbl>   <dbl>   <dbl>  <dbl> <dbl>  <dbl> <dbl>\n1 Anhua    Yiya…   30544  10967  6832.    457.   2703  13225  14567  9277. 3955.\n2 Anren    Chen…   28058   4599. 6386.    221.   1455.  4941. 12761  4189. 2555.\n3 Anxiang  Chan…   31935   5517. 3541     244.   1780. 12482  23667  5109. 2807.\n4 Baojing  Huna…   30843   2250  1005.    193.   1379.  4088. 14563  3624. 1254.\n5 Chaling  Zhuz…   31251   8241. 6508.    620.   1947  11585  20078  9158. 4287.\n6 Changni… Heng…   28518  10860  7920     770.   2632. 19886  24418 37392  4243.\n# … with 18 more variables: NIPCR <dbl>, Bed <dbl>, Emp <dbl>, EmpR <dbl>,\n#   EmpRT <dbl>, Pri_Stu <dbl>, Sec_Stu <dbl>, Household <dbl>,\n#   Household_R <dbl>, NOIP <dbl>, Pop_R <dbl>, RSCG <dbl>, Pop_T <dbl>,\n#   Agri <dbl>, Service <dbl>, Disp_Inc <dbl>, RORP <dbl>, ROREmp <dbl>, and\n#   abbreviated variable names ¹​avg_wage, ²​deposite\n```\n:::\n:::\n\n\n3.4.3 Perform relational join\n\nTo combine the information in the shapefile and the attribute data, we perform a left_join (from dplyr package) using the county name that is available under *NAME_3* column of the Hunan shapefile and the *County* column n the Hunan attribute file\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan = left_join(hunan,hunan2012,\n                  by =c(\"NAME_3\"=\"County\"))\n```\n:::\n\n\n3.4.4 Visualise Regional Development Indicator\n\nWe prepare a basemap and a choropleth map showing the distribution of GDP per capita (GDPPC) 2012 by using qtm() of tmap package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasemap = tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.35) +\n  tm_layout(main.title = \"Basemap of Hunan province, China\",\n          main.title.position = \"center\",\n          main.title.size = 1.2)\n\ngdppc =qtm(hunan, fill = \"GDPPC\",\n          legend.height = 0.25, \n          legend.width = 0.35,\n          legend.outside = FALSE,\n          legend.position = c(\"right\", \"bottom\")\n          ) +\n          tm_layout(main.title = \"Distribution of GDPPC, 2012\",\n          main.title.position = \"center\",\n          main.title.size = 1.2)\n\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n3.5 Compute Contiguity Spatial Weights\n\nWe will use [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package to compute contiguity weight matrices. The function builds a neighbours list based on regions with contiguous boundaries, that is sharing one or more boundary point. The function uses the Queen criteria by default (see section 3.5.3 to use the Rook criteria).\n\n3.5.1 Compute contiguity based neighbors using Queen method\n\nThe code chunk below is used to compute Queen contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan.\n\nThere are two area units - regions 30 and 65 - with only one neighbor.\n\nThe most connected area unit - region 85 - has 11 neighbors.\n\n3.5.1.1 List all neighboring polygons\n\nFor example, to see the neighbors for the first polygon in the object, type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4 57 85\n```\n:::\n:::\n\n\nPolygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.\n\n3.5.1.2 Retrieve the county name of Polygon ID=1\n\nWe can use the following code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$County[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Anxiang\"\n```\n:::\n:::\n\n\n3.5.1.3 Review the county names of neighboring ploygons\n\nWe can use the following code chunk:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$NAME_3[wm_q[[1]]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n```\n:::\n:::\n\n\nor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$NAME_3[c(2,3,4,57,85)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n```\n:::\n:::\n\n\n3.5.1.4 Retrieve the GDPPC of the neighboring counties\n\nWe can use the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb1 = wm_q[[1]]\nnb1 = hunan$GDPPC[nb1]\nnb1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20981 34592 24473 21311 22879\n```\n:::\n:::\n\n\n3.5.1.5 Display the weight matrix of all the 88 area units by using the str() method\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n```\n:::\n:::\n\n\n3.5.2 Compute contiguity based neighbors using Rook method\n\nThe code chunk below is used to compute Rook contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. Similar to the Queen's method, the most connected area unit - Region 85 - has 10 neighbors. Two area units - Regions 30 and 65 - only have 1 neighbor.\n\n3.5.3 Visualise contiguity weights using a Connectivity Graph\n\nA connectivity graph takes a point and displays a line to each neighboring point. For polygons, we will typically use the polygon centroids as the connecting points.\n\n3.5.3.1 Prepare the latitude and longitude of the Polygon Centroids om a separate data frame\n\nTo do so, we will use a mapping function to apply the st_centroid method on the geometry column of each area unit/county.\n\nTo get the longitude values, we map the st_centroid function over the geometry column of hunan and access the longitude value through double bracket notation \\[\\[\\]\\] and 1. This allows us to get only the longitude, which is the first value in each centroid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n```\n:::\n\n\nTo get the latitude, we access the second value in each centroid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n\nWe then combine the longitude and latitude values into a data frame object\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords = cbind(longitude,latitude)\n```\n:::\n\n\nWe check the first few observations to see if the values are formatted correctly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n```\n:::\n:::\n\n\n3.5.3.2 Plot Connectivity Map with Queen contiguity\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the base layer\nplot(hunan$geometry, border=\"lightgrey\") \n# Add on the connectivity layer\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\ntitle(main=\"Queen Contiguity\")\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# pch refers to the point symbol (dot)\n# cex refers to the point size\n```\n:::\n\n\n3.5.3.3 Plot Connectivity Map using Rook contiguity\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"blue\")\ntitle(main=\"Rook Contiguity\")\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n3.5.3.4 Plot Connectivity Map using Queen and Rook contiguity\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\ntitle(main=\"Queen Contiguity\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"blue\")\ntitle(main=\"Rook Contiguity\")\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n3.6 Compute distance based neighbors\n\nWe will use the [*dnearneigh()*](https://r-spatial.github.io/spdep/reference/dnearneigh.html) of **spdep** package to derive distance-based weight matrices . The function identifies neighbours of region points by Euclidean distance with a distance band with lower distance bound (d1), and upper distance bound (d2).\n\n3.6.1 Determine the cut-off distance\n\nWe need to determine the upper limit for distance band by using the steps below so that all area units will have at least 1 neighbor:\n\n-   Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using [*knearneigh()*](https://r-spatial.github.io/spdep/reference/knearneigh.html) of **spdep**. By default k=1 and we can set this argument value explicitly.\n\n-   Convert the knn object returned by *knearneigh()* into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using [*knn2nb()*](https://r-spatial.github.io/spdep/reference/knn2nb.html).\n\n-   Return the length of neighbour relationship edges by using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep**. The function returns the Euclidean distances along the links in a list of the same form as the neighbors list.\n\n-   Remove the list structure of the returned object by using [**unlist()**](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/unlist).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Covers the first 2 points above to prepare a list of nearest neighbor for each area unit\nk1 = knn2nb(knearneigh(coords,k=1))\n# Covers the 3rd and 4th point above to return a vecotor of distances between the area unit and its nearest neighbor\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\n#Summarise the results\nsummary(k1dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n```\n:::\n:::\n\n\nThe summary report shows that the largest first nearest neighbor distance is 61.79 km. This will be used as the upper threshold to provide certainty that all units will have at least one neighbor.\n\n3.6.2 Compute fixed distance weight matrix\n\n3.6.2.1 Compute the distance weight matrix by using *dnearneigh()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d62 = dnearneigh(coords, 0, 62, longlat = TRUE) # longlat = TRUE if point coordinates are geographical longitude-latitude decimal degrees, in which case distances are measured in kilometers\n\nwm_d62\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n```\n:::\n:::\n\n\nBased on the above, within a distance of 62 km for each area unit, the average number of links or connections that the area units have is 3.7.\n\n3.6.2.2 Display the content of wm_d62 weight matrix using str()\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_d62)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n```\n:::\n:::\n\n\n3.6.2.3 Alternative way to display the structure of the weight matrix by using [*table()*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/table) and [*card()*](https://r-spatial.github.io/spdep/reference/card.html) of spdep\n\nThe function *card(nb)* is used to extract the number of neighbors from a \\\"nb\\\" object. The table function tabulates the count results\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(hunan$County, card(wm_d62))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# n.comp.nb() finds the number of disjoint connected subgraphs in the graph depicted by a spatial neighbours list object (or nb.obj)\nn_comp <- n.comp.nb(wm_d62)\n\n# nc column shows the number of disjoint connected subgraphs\nn_comp$nc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# comp.id contains a vector with the indices of the disjoint connected subgraphs that the nodes in nb.obj belong to\ntable(n_comp$comp.id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n 1 \n88 \n```\n:::\n:::\n\n\n3.6.2.4 Plot fixed distance weight matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\ntitle(main = \"Fixed Distance Weight Matrix Plot\")\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nNote: The red links show that nearest neighbor for each area unit, while the black links show the additional neighbors if we set a distance buffer (or cut-off) of 62km.\n\nAlternatively, we can plot the 2 sets of links separately with the nearest neighbor being a subset of the distance linked areas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\ntitle(main = \"1st nearest neighbours\")\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)\ntitle(main = \"Disance-linked neighbours \\n (within 62km)\")\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n3.6.3 Compute adaptive distance weight matrix\n\nTo control the numbers of neighbors directly using k-nearest neighbors, we can tweak the k argument in the *knearneigh()* function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn6 <- knn2nb(knearneigh(coords, k=6))\nknn6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n```\n:::\n:::\n\n\nSimilarly, we can display the content of the matrix by using *str()* and note that each county has exactly 6 neighbors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(knn6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n```\n:::\n:::\n\n\n3.6.3.1 Plot distance-based neighbors\n\nWe can run the following codes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\")\nplot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\ntitle(main = \"Disance-based Neighbours \\n (with k = 6)\")\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n3.7 Weights based on Inversed Distance method\n\nFirst, we compute the distances between areas (defined by Queen contiguity discussed in section 3.5.3.2) using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute the inverse of distances between a county and its neighbors\ndist <- nbdists(wm_q, coords, longlat = TRUE)\nids <- lapply(dist, function(x) 1/(x))\n\n# Display first 6 rows of ids\nhead(ids)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n[[4]]\n[1] 0.01820896 0.02822040 0.03414741 0.01539065\n\n[[5]]\n[1] 0.03695795 0.03414741 0.01524598 0.01618354\n\n[[6]]\n[1] 0.015390649 0.015245977 0.021748129 0.011883901 0.009810297\n```\n:::\n:::\n\n\n3.7.1 Row-standard weight matrix (rswm)\n\nNext, we need to assign weights to each neighboring polygon using the [nb2listw()](https://www.rdocumentation.org/packages/spdep/versions/1.2-7/topics/nb2listw) function. In our case, each neighboring polygon is assigned equal weight (style=\\\"W\\\") for simplicity\\'s sake. This is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values. While this is the most intuitive way to summaries the neighbors\\' values it has one drawback in that polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data. Note that other more robust options are available, notably style=\\\"B\\\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in the dataset\n# Coding style = \"W\" means row standardisation is used\nrswm_q <- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n:::\n:::\n\n\nRecall that in Section 3.5.1.1 , Polygon 1 has 5 neighbors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4 57 85\n```\n:::\n:::\n\n\nTo see the weights of the 5 neighbors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q$weights[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2 0.2 0.2 0.2 0.2\n```\n:::\n:::\n\n\nEach neighbor is assigned a 0.2 of the total weight. This means that when R computes the average neighboring income values, each neighbor\\'s income will be multiplied by 0.2 before being tallied.\n\nUsing the same method, we can also derive a row standardised distance weight matrix (based on Inversed Distance) by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_ids <- nb2listw(wm_q, glist=ids, style=\"B\", zero.policy=TRUE)\nrswm_ids\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n```\n:::\n:::\n\n\nTo see the distance weights of the 5 neighbors for Polygon 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_ids$weights[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n```\n:::\n:::\n\n\nSummary of the distance weights\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(unlist(rswm_ids$weights))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338 \n```\n:::\n:::\n\n\n3.8 Application of Spatial Weight Matrix\n\nThe lag.listw() function (from spdep package) uses a \"listw\" sparse representation of a spatial weights matrix to compute the lag vector Vx.\nA listw object is typically created by nb2listw() function.\n\n3.8.1 Spatial lag with row-standardized weights\n\nWe compute the average neighbor GDPPC value for each polygon. These values are often referred to as **spatially lagged values.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n```\n:::\n:::\n\n\nWe can append the spatially lag GDPPC values onto hunan sf data frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert 2 separate lists into a list of lists\nlag.list = list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\n# Convert lag.list to a dataframe lag.res\nlag.res = as.data.frame(lag.list)\n# Rename the 2 columns in lag.res table\ncolnames(lag.res) = c(\"NAME_3\", \"lag GDPPC\")\n# Join lag.res wtih hunan\nhunan <- left_join(hunan,lag.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"NAME_3\"\n```\n:::\n:::\n\n\nThe following table shows the average neighboring income values (stored in the Inc.lag object) for the first 6 counties\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 6 features and 36 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp lag GDPPC\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262  24847.20\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756  22724.80\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757  24143.25\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558  27737.50\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065  27270.25\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n```\n:::\n:::\n\n\nNext, we plot both the GDPPC and spatial lag GDPPC for comparison using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc =  qtm(hunan, \"GDPPC\") +\n          tm_layout(main.title = \"Distribution of GDPPC, 2012 \\n   \",\n          main.title.position = \"center\",\n          main.title.size = 1.2,\n          legend.height = 0.26, \n          legend.width = 0.40)\n\n\nlag_gdppc = qtm(hunan, \"lag GDPPC\") +\n            tm_layout(main.title = \"Distribution of Lag GDPPC, 2012 \\n (Row Standardised)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n\n3.8.2 Spatial lag as a sum of neighboring values\n\nWe can calculate spatial lag as a sum of neighboring values by assigning binary weights. This requires us to go back to our neighbors list, then apply a function that will assign binary weights, then we use glist = in the nb2listw function to explicitly assign these weights.\n\nWe start by applying a function that will assign a value of 1 per each neighbor. This is done with lapply, which we have been using to manipulate the neighbors structure throughout the past notebooks. Basically it applies a function across each value in the neighbors structure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights <- lapply(wm_q, function(x) 0*x + 1)\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n```\n:::\n:::\n\n\nWith the proper weights assigned, we use *lag.listw()* to compute a lag variable from our weight and GDPPC.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_sum = list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res = as.data.frame(lag_sum)\ncolnames(lag.res) = c(\"NAME_3\", \"lag_sum GDPPC\")\n```\n:::\n\n\nWe examine the results by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_sum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n```\n:::\n:::\n\n\nWe append the *lag_sum GDPPC* field into `hunan` sf data frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, lag.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"NAME_3\"\n```\n:::\n:::\n\n\nFinally, we plot both the *GDPPC* and *Spatial Lag Sum GDPPC* for comparison using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc =   qtm(hunan, \"GDPPC\")+\n          tm_layout(main.title = \"Distribution of GDPPC, 2012 \\n   \",\n          main.title.position = \"center\",\n          main.title.size = 1.2,\n          legend.height = 0.26, \n          legend.width = 0.40)\n\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\") + \n            tm_layout(main.title = \"Distn of Lag_Sum GDPPC, 2012\\n(sum of neighboring values)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)  \n          \ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-48-1.png){width=672}\n:::\n:::\n\n\n3.8.3 Spatial window average\n\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element (the data points for the county itself) before assigning weights.\n\n![](images/paste-A65D1629.png)\n\nWe first assign wm_q to a new variable because we will directly alter its structure to add the diagonal elements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q1 <- wm_q\n```\n:::\n\n\nTo add the diagonal element to the neighbour list, we just need to use *include.self()* from **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninclude.self(wm_q1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n```\n:::\n:::\n\n\nWe obtain the new weights with *nb2listw()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q1 <- nb2listw(wm_q1)\nwm_q1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n:::\n:::\n\n\nAgain, we create the lag variable from our weight structure and GDPPC variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_w_avg_gpdpc <- lag.listw(wm_q1, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n```\n:::\n:::\n\n\nThe code chunk below will be used to append *lag_window_avg GDPPC* values onto *hunan* sf data.frame by using *left_join()* of **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag.list.wm_q1 <- list(hunan$NAME_3, lag.listw(wm_q1, hunan$GDPPC))\nlag_wm_q1.res <- as.data.frame(lag.list.wm_q1)\ncolnames(lag_wm_q1.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\nhunan <- left_join(hunan, lag_wm_q1.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"NAME_3\"\n```\n:::\n:::\n\n\nWe use *qtm()* of **tmap** package is used to plot the GDPPC and lag_window_avg GDPPC map next to each other for quick comparison.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc =   qtm(hunan, \"GDPPC\")+\n          tm_layout(main.title = \"Distribution of GDPPC, 2012 \\n   \",\n          main.title.position = \"center\",\n          main.title.size = 1.2,\n          legend.height = 0.26, \n          legend.width = 0.40)\n\nw_avg_gdppc = qtm(hunan, \"lag_window_avg GDPPC\") + \n            tm_layout(main.title = \"Distn of Lag_Window Avg GDPPC\\n(row-std wghts plus diagonal element)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)  \n\ntmap_arrange(gdppc, w_avg_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n:::\n\n\n3.8.4 Spatial window sum\n\nThe spatial window sum is the counterpart of the window average, but without using row-standardized weights. To do this we assign binary weights to the neighbor structure that includes the diagonal element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q2 <- wm_q\n```\n:::\n\n\nTo add the diagonal element to the neighbour list, we just need to use *include.self()* from **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninclude.self(wm_q2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n```\n:::\n:::\n\n\nNext, we assign binary weights to the neighbor structure that includes the diagonal element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights3 <- lapply(wm_q2, function(x) 0*x + 1)\nb_weights3[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1 1 1\n```\n:::\n:::\n\n\nWe use *nb2listw()* and *glist()* to explicitly assign weight values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights4 <- nb2listw(wm_q2, \n                       glist = b_weights3, \n                       style = \"B\")\nb_weights4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n```\n:::\n:::\n\n\nWith the new weight structure, we can compute the lag variable with *lag.listw()*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc = list(hunan$NAME_3, lag.listw(b_weights4, hunan$GDPPC))\nw_sum_gdppc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n```\n:::\n:::\n\n\nThe code chunk below will be used to append *w_sum GDPPC* values onto *hunan* sf data.frame by using *left_join()* of **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc.res = as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\nhunan <- left_join(hunan, w_sum_gdppc.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"NAME_3\"\n```\n:::\n:::\n\n\nWe use *qtm()* of **tmap** package to plot the GDPPC and lag_sum GDPPC map next to each other for quick comparison.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc =  qtm(hunan, \"GDPPC\") +\n          tm_layout(main.title = \"Distribution of GDPPC, 2012 \\n   \",\n          main.title.position = \"center\",\n          main.title.size = 1.2,\n          legend.height = 0.26, \n          legend.width = 0.40)\n\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\") + \n            tm_layout(main.title = \"Distn of Lag_sum GDPPC\\n(lag sum plus diagonal element)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)  \n\ntmap_arrange(gdppc, w_sum_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](In-Class_Ex1_files/figure-html/unnamed-chunk-61-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "In-Class_Ex1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}