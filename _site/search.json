[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html",
    "href": "Hands-On_Ex/Hands-on_Ex1.html",
    "title": "Hands-On Exercise 1",
    "section": "",
    "text": "Learn how to handle geospatial data in R by using sf package.\nLearn how to plot functional and truthful choropleth maps by using tmap package"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#data-acquisition",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#data-acquisition",
    "title": "Hands-On Exercise 1",
    "section": "1.1 Data Acquisition",
    "text": "1.1 Data Acquisition\nDatasets are acquired from the following areas:\n\nMaster Plan 2014 Subzone Boundary (Web) from data.gov.sg\nPre-Schools Location from data.gov.sg\nCycling Path from LTADataMall\nSingapore Airbnb listing data, 19 July 2021 from Inside Airbnb"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#getting-started",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#getting-started",
    "title": "Hands-On Exercise 1",
    "section": "1.2 Getting Started",
    "text": "1.2 Getting Started\n\n1.2.1 Import libraries\nTwo r packages need to be loaded - ‘sf’ and ‘tidyverse’\n\npacman::p_load(sf,tidyverse)\n\n\n\n1.2.2 Import Geospatial Data using st_read() of sf package\n\n1.2.2.1 Import polygon feature in shape file format using st_read()\nWhen the input geospatial data is in shapefile format, two arguments will be used, namely: dsn to define the data path and layer to provide the shapefile name. Also note that no extension such as .shp, .dbf, .prj and .shx are needed.\n\nmpsz = st_read(dsn = \"Hands-On_Ex1/data/geospatial\", \n                  layer = \"MP14_SUBZONE_WEB_PL\") # The dsn path is with reference to the .qmd document created to house this page\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\Cabbie-UK\\ISSS624\\Hands-On_Ex\\Hands-On_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nFrom the results above, to check that we are using “Projected CRS” for the coordinates to be reflected in a 2-D space so that we can measure distance accurately.\n\n\n1.2.2.2 Import polyline feature data in shapefile format\n\ncyclingpath = st_read(dsn = \"Hands-On_Ex1/data/geospatial\", \n                         layer = \"CyclingPath\")\n\nReading layer `CyclingPath' from data source \n  `C:\\Cabbie-UK\\ISSS624\\Hands-On_Ex\\Hands-On_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\n\n1.2.2.3 Import GIS data in kml format\n\npreschool = st_read(\"Hands-On_Ex1/data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\Cabbie-UK\\ISSS624\\Hands-On_Ex\\Hands-On_Ex1\\data\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#check-the-content-of-a-simple-feature-dataframe",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#check-the-content-of-a-simple-feature-dataframe",
    "title": "Hands-On Exercise 1",
    "section": "1.3 Check the content of a simple feature dataframe",
    "text": "1.3 Check the content of a simple feature dataframe\nDifferent ways to retrieve content information of a simple feature data frame\n\n1.3.1 Use st_geometry()\nTo display basic information of the feature class such as type of geometry, the geographic extent of the features and the coordinate system of the data\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\n\n\n1.3.2 Use glimpse() of dplyr\nTo learn more about the associated attribute information in the data frame in addition to the basic feature information.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\n\n\n1.3.3 Use head()\nTo reveal complete information of a feature object\n\nhead(mpsz, n=5) \n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30..."
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#plot-the-geospatial-data",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#plot-the-geospatial-data",
    "title": "Hands-On Exercise 1",
    "section": "1.4 Plot the Geospatial Data",
    "text": "1.4 Plot the Geospatial Data\nTo see some of the geospatial features in the dataframe, we use plot()\n\nplot(mpsz)\n\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall\n\n\n\n\n\nThe default plot of an sf object is a multi-plot of all attributes, up to a reasonable maximum as shown above. We can, however, choose to plot only the geometry by using the code chunk below.\n\nplot(st_geometry(mpsz))\n\n\n\n\nAlternatively, we can also choose the plot the sf object by using a specific attribute as shown in the code chunk below.\n\nplot(mpsz[\"REGION_C\"])\n\n\n\n\nNote: plot() is mean for plotting the geospatial object for quick look. For high cartographic quality plot, other R package such as tmap should be used."
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#map-projection",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#map-projection",
    "title": "Hands-On Exercise 1",
    "section": "1.5 Map Projection",
    "text": "1.5 Map Projection\nIn a map projection, coordinates, often expressed as latitude and longitude, of locations from the surface of the globe are transformed to coordinates on a plane. Projection is a necessary step in creating a two-dimensional map and is one of the essential elements of cartography. (source: Map projection - Wikipedia)\nIn order to perform geoprocessing using two geospatial data, we need to ensure that both geospatial data are projected using similar coordinate system. The process to project a simple feature data frame from one coordinate system to another coordinate system is called projection transformation.\n\n1.5.1 Assign EPSG code to a simple feature data frame\nOne common issue that can happen during importing geospatial data into R is that the coordinate system of the source data was either missing (such as due to missing .proj for ESRI shapefile) or wrongly assigned during the importing process.\nThis is an example the coordinate system of mpsz simple feature data frame by using st_crs() of sf package as shown in the code chunk below.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nAlthough mpsz data frame is projected in svy21 but when we read until the end of the print, it indicates that the EPSG is 9001. This is a wrong EPSG code because the correct EPSG code for svy21 should be 3414.\nIn order to assign the correct EPSG code to mpsz data frame, st_set_crs() of sf package is used as shown in the code chunk below.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nNow, let us check the CSR again by using the code chunk below.\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\n1.5.2 Transform the projection of preschool from wgs84 to svy21\nIn geospatial analytics, it is very common for us to transform the original data from geographic coordinate system to projected coordinate system when the analysis need to use distance or/and area measurements.\nLet us take preschool simple feature data frame as an example. The print below reveals that it is in wgs84 coordinate system.\n\nst_crs(preschool)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nLet us perform the projection transformation by using the code chunk below with st_transform()\n\npreschool3414 <- st_transform(preschool, \n                              crs = 3414)\n\nLet us display the content of preschool3414 sf data frame as shown below. The coordinate system is now EPSG:3414\n\nst_crs(preschool3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#import-and-convert-an-aspatial-datafile",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#import-and-convert-an-aspatial-datafile",
    "title": "Hands-On Exercise 1",
    "section": "1.6 Import and convert an aspatial datafile",
    "text": "1.6 Import and convert an aspatial datafile\nAspatial data it is not a geospatial data but among the data fields, there are two fields that capture the x- and y-coordinates of the data points.\n\n1.6.1 Import aspatial data\nWe will use read_csv() of readr package to import listing.csv and display part of the list as shown the code chunk below.\n\nlistings <- read_csv(\"Hands-On_Ex1/data/aspatial/listings.csv\")\n\nRows: 4252 Columns: 16\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (5): name, host_name, neighbourhood_group, neighbourhood, room_type\ndbl  (10): id, host_id, latitude, longitude, price, minimum_nights, number_o...\ndate  (1): last_review\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,252 × 16\n       id name     host_id host_…¹ neigh…² neigh…³ latit…⁴ longi…⁵ room_…⁶ price\n    <dbl> <chr>      <dbl> <chr>   <chr>   <chr>     <dbl>   <dbl> <chr>   <dbl>\n 1  50646 Pleasan…  227796 Sujatha Centra… Bukit …    1.33    104. Privat…    80\n 2  71609 Ensuite…  367042 Belinda East R… Tampin…    1.35    104. Privat…   178\n 3  71896 B&B  Ro…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 4  71903 Room 2-…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 5 275343 Conveni… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    52\n 6 275344 15 mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    40\n 7 294281 5 mins … 1521514 Elizab… Centra… Newton     1.31    104. Privat…    72\n 8 301247 Nice ro… 1552002 Rahul   Centra… Geylang    1.32    104. Privat…    41\n 9 324945 20 Mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n10 330089 Accomo@… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n# … with 4,242 more rows, 6 more variables: minimum_nights <dbl>,\n#   number_of_reviews <dbl>, last_review <date>, reviews_per_month <dbl>,\n#   calculated_host_listings_count <dbl>, availability_365 <dbl>, and\n#   abbreviated variable names ¹​host_name, ²​neighbourhood_group,\n#   ³​neighbourhood, ⁴​latitude, ⁵​longitude, ⁶​room_type\n\n\nThe output reveals that listing tibble data frame consists of 4252 rows and 16 columns. Two useful fields we are going to use in the next phase are latitude and longitude.\n\n\n1.6.2 Create a simple feature data frame from an aspatial data frame\nThe code chunk below converts listing data frame into a simple feature data frame by using st_as_sf()\n\nlistings_sf <- st_as_sf(listings, \n                       coords = c(\"longitude\", \"latitude\"),\n                       crs=4326) %>%\n  st_transform(crs = 3414)\n\nThings to learn from the arguments above:\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n%>% is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.\n\nLet us examine the content of this newly created simple feature data frame.\n\nglimpse(listings_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <dbl> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <dbl> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <dbl> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <dbl> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <dbl> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <date> 2014-07-08, 2019-12-28, 2014-12-10, 20…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <dbl> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <dbl> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#geoprocessing-with-sf-package",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#geoprocessing-with-sf-package",
    "title": "Hands-On Exercise 1",
    "section": "1.7 Geoprocessing with sf package",
    "text": "1.7 Geoprocessing with sf package\nsf package also offers a wide range of geoprocessing (also known as GIS analysis) functions.\n\n1.7.1 Buffering\nThe scenario:\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nThe solution:\nFirstly, st_buffer() of sf package is used to compute the 5-meter buffers around cycling paths\n\nbuffer_cycling <- st_buffer(cyclingpath, \n                               dist=5, nQuadSegs = 30)\n\nThis is followed by calculating the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\n1.7.2 Point-in-polygon count\nThe scenario:\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution:\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$`PreSch Count`<- lengths(st_intersects(mpsz3414, preschool3414))\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      290          3 WOODLANDS EAST    WDSZ03      N  WOODLANDS         WD\n      REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 NORTH REGION       NR C90769E43EE6B0F2 2014-12-05 24506.64 46991.63\n  SHAPE_Leng SHAPE_Area                       geometry PreSch Count\n1   6603.608    2553464 MULTIPOLYGON (((24786.75 46...           37\n\n\nThe scenario:\nCalculate the density of pre-school by planning subzone\nThe solution:\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)\n\nA peek at the resutling dataframe\n\nhead(mpsz3414)\n\nSimple feature collection with 6 features and 18 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 24468.89 ymin: 28369.47 xmax: 32362.39 ymax: 30542.74\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n6        6          7 ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6         BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry PreSch Count\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...            0\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...            5\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...            0\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...            2\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...            1\n6 29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...           10\n             Area   PreSch Density\n1 1630379.3 [m^2] 0.000000 [1/m^2]\n2  559816.2 [m^2] 8.931502 [1/m^2]\n3  160807.5 [m^2] 0.000000 [1/m^2]\n4  595428.9 [m^2] 3.358923 [1/m^2]\n5  387429.4 [m^2] 2.581115 [1/m^2]\n6 1030378.8 [m^2] 9.705169 [1/m^2]"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#explorotary-data-analysis-eda",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#explorotary-data-analysis-eda",
    "title": "Hands-On Exercise 1",
    "section": "1.8 Explorotary Data Analysis (EDA)",
    "text": "1.8 Explorotary Data Analysis (EDA)\nWe will use appropriate ggplot2 functions to create functional and yet truthful statistical graphs for EDA purposes.\nFirstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.\n\nhist(mpsz3414$`PreSch Density`)\n\n\n\n\nAlthough the syntax is very easy to use however the output is far from meeting publication quality. Furthermore, the function has limited room for further customisation.\nIn the code chunk below, appropriate ggplot2 functions will be used.\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\nThis is a scatterplot showing the relationship between Pre-school Density and Pre-school Count\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`),y=as.numeric(`PreSch Count`)))+\n  geom_point() +\n  labs(title = \"Pre-School Count vs Pre-School Density\",\n       x = \"Pre-school density (per km sq)\",\n       y = \"Pre-school count\")"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#import-data-into-r",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#import-data-into-r",
    "title": "Hands-On Exercise 1",
    "section": "2.1 Import data into R",
    "text": "2.1 Import data into R\n\n2.1.1 The data\nTwo data set will be used to create the choropleth map. They are:\n\nMaster Plan 2014 Subzone Boundary (Web) (i.e. MP14_SUBZONE_WEB_PL) in ESRI shapefile format. It can be downloaded at data.gov.sg This is a geospatial data. It consists of the geographical boundary of Singapore at the planning subzone level. The data is based on URA Master Plan 2014.\nSingapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format (i.e. respopagesextod2011to2020.csv). This is an aspatial data fie. It can be downloaded at Department of Statistics, Singapore Although it does not contain any coordinates values, but it’s PA and SZ fields can be used as unique identifiers to geocode to MP14_SUBZONE_WEB_PL shapefile.\n\n\n\n2.1.2 Import Geospatial Data into R\nThe code chunk below uses the st_read() function of sf package to import MP14_SUBZONE_WEB_PL shapefile into R as a simple feature data frame called mpsz.\n\nmpsz <- st_read(dsn = \"Hands-On_Ex1/data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\Cabbie-UK\\ISSS624\\Hands-On_Ex\\Hands-On_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nYou can examine the content of mpsz by using the code chunk below.\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n\n\n\n\n2.1.3 Import attribute data into R\nWe will import respopagsex2000to2018.csv file into RStudio and save the file into an R dataframe called popagsex.\n\npopdata <- read_csv(\"Hands-On_Ex1/data/aspatial/respopagesextod2011to2020.csv\",show_col_types = FALSE)\n\n\n\n2.1.4 Data Preparation\nWe need to prepare a data table that includes the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.\n\nYOUNG: age group 0 to 4 until age groyup 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\n2.1.4.1 Data Wrangling\nThe following data wrangling and transformation functions will be used:\n\npivot_wider() of tidyr package, and\nmutate(), filter(), group_by() and select() of dplyr package\n\n\npopdata2020 = popdata %>%\n  filter(Time==2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP`=sum(`Pop`)) %>%\n  ungroup() %>%\n  pivot_wider(names_from = AG, values_from = POP) %>%\n  mutate(YOUNG = rowSums(.[3:6]) + rowSums(.[12])) %>%\n  mutate(`ECONOMIC ACTIVE`= rowSums(.[7:11]) + rowSums(.[13:15])) %>%\n  mutate(`AGED`=rowSums(.[16:21])) %>%\n  mutate(`TOTAL`=rowSums(.[3:21])) %>%\n  mutate(`DEPENDENCY`= (`YOUNG`+`AGED`)/`ECONOMIC ACTIVE`) %>%\n  select(`PA`,`SZ`,`YOUNG`,`ECONOMIC ACTIVE`,`AGED`,`TOTAL`,`DEPENDENCY`)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\n\n\n\n2.1.4.1 Join the attribute data and geospatial data\nBefore we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.\n\npopdata2020 = popdata2020 %>%\n  mutate_at(.vars = vars(PA, SZ),\n            .funs = funs(toupper)) %>%\n  filter(`ECONOMIC ACTIVE` > 0)\n\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nPlease use a list of either functions or lambdas: \n\n  # Simple named list: \n  list(mean = mean, median = median)\n\n  # Auto named with `tibble::lst()`: \n  tibble::lst(mean, median)\n\n  # Using lambdas\n  list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\nThis warning is displayed once every 8 hours.\nCall `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n\n\nNext, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name e.g. SUBZONE_N and SZ as the common identifier.\n\nmpsz_pop2020 = left_join(mpsz,popdata2020,\n                         by =c(\"SUBZONE_N\"=\"SZ\"))\n\nThing to learn from the code chunk above:\n\nleft_join() of dplyr package is used with mpsz simple feature data frame as the left data table is to ensure that the output will be a simple features data frame.\n\n\nwrite_rds(mpsz_pop2020, \"Hands-On_Ex1/data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex1.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-On_Ex/Hands-on_Ex1.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Hands-On Exercise 1",
    "section": "2.2 Choropleth Mapping Geospatial Data Using tmap",
    "text": "2.2 Choropleth Mapping Geospatial Data Using tmap\nTwo ways to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements\n\n\npacman::p_load(tmap) # load tmap package\n\n\n2.2.1 Quick plot using qtm()\nIt is concise and provides a good default visualisation in many cases. The code chunk below will draw a cartographic standard choropleth map as shown below.\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n\n\n\n\nThings to note from the code chunk above:\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\n\n2.2.2 Create a choropleth map by using tmap’s elements\nqtm() makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, tmap’s drawing elements should be used.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n2.2.2.1 Draw a base map\nThe basic building block of tmap is tm_shape() followed by one or more layer elemments such as tm_fill() and tm_polygons().\nIn the code chunk below, tm_shape() is used to define the input data (i.e mpsz_pop2020) and tm_polygons() is used to draw the planning subzone polygons\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\n2.2.2.2 Draw a choropleth map using tm_polygons()\nTo draw a choropleth map showing the geographical distribution of a selected variable by planning subzone, we just need to assign the target variable such as Dependency to tm_polygons().\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\nThings to note from tm_polygons():\n\nThe default interval binning used to draw the choropleth map is called “pretty”. A detailed discussion of the data classification methods supported by tmap will be provided in sub-section 2.2.3.\nThe default colour scheme used is YlOrRd of ColorBrewer. You will learn more about the color scheme in sub-section 2.2.4.\nBy default, Missing value will be shaded in grey.\n\n\n\n2.2.2.3 Drawing a choropleth map using tm_fill() and tm_border()\nActually, tm_polygons() is a wraper of tm_fill() and tm_border(). tm_fill() shades the polygons by using the default colour scheme and tm_borders() adds the borders of the shapefile onto the choropleth map.\nThe code chunk below draws a choropleth map by using tm_fill() alone.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\nTo add the boundary of the planning subzones, tm_borders will be used as shown in the code chunk below.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1)\n\n\n\n\nNotice that light-gray border lines have been added on the choropleth map.\nThe alpha argument is used to define transparency number between 0 (totally transparent) and 1 (obaque). By default, the alpha value of the col is used (normally 1).\nBeside alpha argument, there are three other arguments for tm_borders(), they are:\n\ncol = border colour,\nlwd = border line width. The default is 1, and\nlty = border line type. The default is “solid”.\n\n\n\n\n2.2.3 Data classification methods of tmap\nMost choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.\n\nstyle = pretty: Rounds interval boundaries to whole numbers. Default setting.\nstyle = equal: Splits the variable into intervals of equal length. Should only be used if the variable follows an uniform distribution.\nstyle = quantile: Splits the variable into quantiles. Consequently there are the same number of observations in each interval.\nstyle = jenks: Identifies groups with similar values and maximizes the difference between them.\n\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\n2.2.3.1 Plot choropleth maps with built-in classification methods\nThe code chunk below shows a quantile data classification that used 5 classes.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nIn the code chunk below, equal data classification method is used.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nNotice that the distribution of quantile data classification method are more evenly distributed then equal data classification method.\nUsing pretty style with the following code chunk.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"pretty\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n2.2.3.2 Plot choropleth map with customise break\nFor all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_fill(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).\nBefore we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\nWith reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 19. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 19.00)\nNow, we will plot the choropleth map by using the code chunk below.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 19.00)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n2.2.4 Color Scheme\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.\n\n2.2.4.1 Use ColourBrewer palette\nTo change the colour, we assign the preferred colour to palette argument of tm_fill() as shown in the code chunk below.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Purples\") + # Reds, Blues will work as well\n  tm_borders(alpha = 0.5)\n\n\n\n\nTo reverse the colour shading, add a “-” prefix.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n2.2.5 Map Layouts\nMap layout refers to the combination of all map elements into a cohensive map. Map elements include among others the objects to be mapped, the title, the scale bar, the compass, margins and aspects ratios. Colour settings and data classification methods covered in the previous section relate to the palette and break-points are used to affect how the map looks.\n\n2.2.5.1 Map Legend\nIn tmap, several legend options are provided to change the placement, format and appearance of the legend.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n2.2.5.2 Map style\ntmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style().\nThe code chunk below shows the classic style is used.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\ntmap style set to \"classic\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"watercolor\" \n\n\n\n\n\nOther available styles are: “white”, “gray”, “natural”, “cobalt”, “col_blind”, “albatross”, “beaver”, “bw”, “watercolor”\n\n\n2.2.5.3 Cartographic Furniture\ntmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.\nIn the code chunk below, tm_compass(), tm_scale_bar() and tm_grid() are used to add compass, scale bar and grid lines onto the choropleth map.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"4star\", size = 2) + # can set 8star as well\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\nTo reset the default style, refer to the code chunk below.\n\ntmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n2.2.6 Drawing Small Multiple Choropleth Maps\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\n\n2.2.6.1 Assign multiple values to at least one of the aesthetic arguments\nIn this example, small multiple choropleth maps are created by defining ncols in tm_fill()\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nIn the following example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\n\n\n2.2.6.2 Define a group-by variable in tm_facets()\nIn the following example, multiple small choropleth maps are created by using tm_facets().\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.units = TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n2.2.6.3 Create multiple stand-alone maps with tmap_arrange()\nIn the following example, multiple small choropleth maps are created by creating multiple stand-alone maps with tmap_arrange().\n\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n\n2.2.7 Mapp Spatial Object Meeting a Selection Criterion\nInstead of creating small multiple choropleth map, you can also use selection funtion to map spatial objects meeting the selection criterion.\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html",
    "href": "Hands-On_Ex/Hands-on_Ex2.html",
    "title": "Hands-On Exercise 2",
    "section": "",
    "text": "Updated on 28-Nov-22\n(First published on 25-Nov-22)"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#overview",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#overview",
    "title": "Hands-On Exercise 2",
    "section": "4.1 Overview",
    "text": "4.1 Overview\nUse appropriate functions from R spdep and tmap packages to:\n\nCompute Global Spatial Autocorrelation (GSA) statistics\nCompute Local Indicator of Spatial Association (LISA) statistics for detecting clusters and outlines\nCompute Getis-Ord’s Gi-Statisitics for detecting hot spot or/and cold spot areas\nVisualise the analysis output by using the tmap package"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#getting-started",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#getting-started",
    "title": "Hands-On Exercise 2",
    "section": "4.2 Getting started",
    "text": "4.2 Getting started\nOur task in this study is to apply appropriate spatial statistical methods to discover if development in Hunan province of China is evenly distributed geographically.\n\nWe will use GDP per capita (GDPPC) as the measure of development.\n\n4.2.1 Datasets available\nThey are:\n\nHunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\n\n\n4.2.2 Install and load the relevant R packages for the exercise\n\npacman::p_load(sf,spdep,tmap,tidyverse, ggplot2)"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#getting-the-data-in-r-environment",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#getting-the-data-in-r-environment",
    "title": "Hands-On Exercise 2",
    "section": "4.3 Getting the data in R environment",
    "text": "4.3 Getting the data in R environment\n\n4.3.1 Import the ESRI shapefile\n\nhunan = st_read(dsn = \"Hands-On_Ex2/data/geospatial\",layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `C:\\Cabbie-UK\\ISSS624\\Hands-On_Ex\\Hands-On_Ex2\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\n4.3.2 Import the Development Indicators .csv file\n\nhunan2012 = read_csv(\"Hands-On_Ex2/data/aspatial/Hunan_2012.csv\",show_col_types = FALSE)\n\n\n\n4.3.3 Perform relational join\nTo append the development indicators information into the hunan SpatialPolygonsDataFrame using a left_join().\n\nhunan = left_join(hunan,hunan2012)\n\nJoining, by = \"County\"\n\n\n\n\n4.3.4 Visualise Regional Development Indicator\nWe prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package\n\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Quantile interval classification\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#global-spatial-autocorrelation",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#global-spatial-autocorrelation",
    "title": "Hands-On Exercise 2",
    "section": "4.4 Global Spatial Autocorrelation",
    "text": "4.4 Global Spatial Autocorrelation\nIn this section, we learn how to compute global spatial autocorrelation statistics and to perform spatial complete randomness test for global spatial autocorrelation.\n\n4.4.1 Compute Contiguity Spatial Weights\nBefore we compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. The spatial weights is used to define the neighborhood relationships between the geographical units (i.e. counties) in the study area.\n(This is covered in Section 3.6.3 of In-Class Ex1)\nIn the code chunk below, poly2nb() of spdep package is used to compute contiguity weight matrices for the study area. This function builds a neighbors list based on regions with contiguous boundaries.\n\n# Compute continguity weight matrices using Queen method\nwm_q <- poly2nb(hunan, queen=TRUE)\n\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nThe summary report above shows that there are 88 area units in Hunan. There are two area units - regions 30 and 65 - with only one neighbor. The most connected area unit - region 85 - has 11 neighbors.\n\n\n4.4.2 Row-standardised weights matrix\nNext, we need to assign weights to each neighboring polygon using the nb2listw() function.\n(This is covered in Section 3.7.1 of In-Class Ex1)\n\nrswm_q <- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nThe input of nb2listw() must be an object of class nb. The syntax of the function has two major arguments, namely style and zero.policy.\n\nstyle can take values “W”, “B”, “C”, “U”, “minmax” and “S”. B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).\nIf zero policy is set to TRUE, weights vectors of zero length are inserted for regions without neighbor in the neighbors list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row t(rep(0, length=length(neighbours))) %*% x, for arbitrary numerical vector x of length length(neighbours). The spatially lagged value of x for the zero-neighbor region will then be zero, which may (or may not) be a sensible choice.\n\n\n\n4.4.3 Global Spatial Autocorrelation: Moran’s I\nThe Global Moran’s I is a global statistic that provides us with a single value for our entire data set to describe if a variable of interest corresponds to the first law of geography - everything is related, but things that are closer together are more related than things further away. The Global Moran’s I operates by comparing how similar every object (such as its GDPPC) is to its neighbors, and then averaging out all of these comparisons to give us an overall impression about the spatial pattern of the variable.\nIn this section, we learn how to compute Moran’s I statistics testing by using moran.test() of spdep.\n\n4.4.3.1 Maron’s I test\nThe Spatial Autocorrelation (Global Moran’s I) tool measures spatial autocorrelation based on both feature locations and feature values simultaneously. Given a set of features and an associated attribute, it evaluates whether the pattern expressed is clustered, dispersed, or random. The tool calculates the Moran’s I Index value and both a a z-score and p-value to evaluate the significance of the Index. P-values are numerical approximations of the area under the curve for a known distribution, limited by the test statistic.\n\n#\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nThe Spatial Autocorrelation (Global Moran’s I) tool is an inferential statistic, which means that the results of the analysis are always interpreted within the context of its null hypothesis. For the Global Moran’s I statistic, the null hypothesis states that the attribute being analyzed is randomly distributed among the features in the study area; said another way, the spatial processes promoting the observed pattern of values is random chance.\nWhen the p-value returned by this tool is statistically significant, we can reject the null hypothesis. The table below summarizes interpretation of results:\n\n\n\n\n\n\n\n\n\n\n\n\nThe p-value is not statistically significant\nWe cannot reject the null hypothesis. It is quite possible that the spatial distribution of feature values is the result of random spatial processes. The observed spatial pattern of feature values could very well be one of many possible versions of complete spatial randomness.\n\n\nThe p-value is statistically significant, and the z-score is positive.\nWe may reject the null hypothesis. The spatial distribution of high values and/or low values in the dataset is more spatially clustered than would be expected if underlying spatial processes were random.\n\n\nThe p-value is statistically significant, and the z-score is negative.\nWe may reject the null hypothesis. The spatial distribution of high values and low values in the dataset is more spatially dispersed than would be expected if underlying spatial processes were random. A dispersed spatial pattern often reflects some type of competitive process—a feature with a high value repels other features with high values; similarly, a feature with a low value repels other features with low values.\n\n\n\nThe Moran’s I statistic is 0.3007, a positive value implies that there’s some degree of clustering. The p-value is <0.01 implying that we can reject the null hypothesis.\n\n\n4.4.3.2 Compute Monte Carlo Moran’s I\nThe analytical approach to the Moran’s I analysis benefits from being fast. But it may be sensitive to irregularly distributed polygons. A safer approach to hypothesis testing is to run an Monte Carlo (MC) C simulation using the moran.mc() function. The moran.mc function takes an extra argument n, the number of simulations.\nThe code chunk below performs permutation test for Moran’s I statistic. A total of 1000 simulation will be performed.\n\nset.seed(1234)\nbperm= moran.mc(hunan$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe MC simulation generates a very small p-value, 0.001. The simulated Moran I statisitic of 0.30075 is close to the computed one in the previous section . We can see the results graphically by passing the Moran’s I model to the plot function in the next section.\n\n\n4.4.3.3 Visualise Monte Carlo Moran’s I\nWe first examine some summary statistics of the simulated Moran’s I.\n\nmean(bperm$res[1:999])\n\n[1] -0.01504572\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.004371574\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n\n\nNext we plot the distribution of the statistical values as a histogram by using the code chunk below.\n\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0.30075, \n       col=\"red\")\n\n\n\n\nThe curve shows the distribution of Moran I values we could expect had the GDPPC been randomly distributed across the counties.\n\n# Convert the S3 object to a dataframe as ggplot can only work with the latter\nbperm.res = as.data.frame(bperm$res)\n\n# Plot the histogram\nggplot(data = bperm.res, aes(x=bperm$res)) +\n  geom_histogram(bins = 25, color='black',fill=\"lightblue\") +\n  labs(y='Frequency',x=\"Simulated Mohan's I\", title = \"Histogram of bperm$rep\") +\n  theme(plot.title=element_text(hjust=0.5)) +\n  geom_vline(xintercept = 0.30075, color=\"red\")\n\n\n\n\nNote that our observed statistic, 0.300, falls to the right of the distribution suggesting that the GDPPC values are clustered and the result is significant.\n\n\n\n4.4.4 Global Spatial Autocorrelation: Geary’s C\nIn this section, we learn how to compute Geary’s C statistics testing by using geary.test() of spdep.\n\n4.4.4.1 Geary’s C test\nGeary’s C is a measure of spatial autocorrelation or an attempt to determine if adjacent observations of the same phenomenon are correlated. The value of Geary’s C lies between 0 and some unspecified value greater than 1.\nGeary’s C (Z value) is:\n\nC = 1: observations are arranged randomly over space\nLarge c value (>1) : Dispersed, observations tend to be dissimilar;\nSmall c value (<1) : Clustered, observations tend to be similar;\n0 <= c value <= 3\n\n\ngeary.test(hunan$GDPPC, listw=rswm_q)\n\n\n    Geary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n\n\nSince p-value < 0.05, the level of significance, we reject the null hypothesis and conclude that the observed spatial pattern of GDPPC is not equally likely as any other spatial pattern (i.e. not spatially random). Also, given that the Geary’s C statistic is < 0.05, there’s some clustering on the map.\n\n\n4.4.4.2 Compute Monte Carlo Geary’s C\nThe code chunk below performs permutation test for Geary’s C statistic by using geary.mc() of spdep\n\nset.seed(1234)\nbperm_c=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm_c\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nWe see that the simulated Geary’s C statistic is similar to the one computed in the previous section with p-value < 0.05.\n\n\n4.4.4.3 Visualise the Monte Carlo Geary’s C\nWe first examine some summary statistics of the simulated Geary’s C values.\n\nmean(bperm_c$res[1:999])\n\n[1] 1.004402\n\n\n\nvar(bperm_c$res[1:999])\n\n[1] 0.007436493\n\n\n\nsummary(bperm_c$res[1:999])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n\n\nNext, we plot a histogram to reveal the distribution of the simulated values by using the code chunk below.\n\nhist(bperm_c$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary's C\")\nabline(v=0.6907223, col=\"red\")\n\n\n\n\nThe simulated results for Moran’s I and Geary’s C statistics are the same. That is, the test statistics are significant and that there’s some degree of clustering on the map."
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#spatial-correlogram",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#spatial-correlogram",
    "title": "Hands-On Exercise 2",
    "section": "4.5 Spatial Correlogram",
    "text": "4.5 Spatial Correlogram\nSpatial correlograms are great to examine patterns of spatial autocorrelation in our data or model residuals. They show how correlated pairs of spatial observations are when we increase the distance (lag) between them - they are plots of some index of autocorrelation (Moran’s I or Geary’s c) against distance.\n\n4.5.1 Compute Moran’s I Correlogram\nIn the code chunk below, sp.correlogram() of spdep package is used to compute a 6-lag spatial correlogram of GDPPC. This will equivalent to examining the 1st to 6th order neighbors of each county.\n\n# Method = \"I\" for Moran's I\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n\n\n\n\nThe Correlogram above shows the diffusing effect of the clustering with each increase in spatial lag of neighbors. That is, back to Tobler’s first law, near neighbors will contribute more to the clustering than distant neighbors. If the Moran’s I statistics of lag 2 to lag 6 decrease at a slower rate, this would mean that the clustering has a wider spread (between the lag 2 and lag 6 neighbors). In practice, the correlogram can used by urban planners to examine whether the development in a region should be spread to its neighboring regions and study the possible implications of doing so.\nTo understand if all autocorrelation values are statistically significant, we examine the full analysis results with the following code chunk:\n\nprint(MI_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n4.5.2 Compute Geary’s C correlogram and plot\nIn the code chunk below, sp.correlogram() of spdep package is used to compute a 6-lag spatial correlogram of GDPPC.\n\n# Method = \"C\" for Geary's C\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n\n\n\n\nWe print out the analysis report by using the code chunk below\n\nprint(GC_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nThe results above show that Moran’s I and Geary’s C values are inversely related."
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#cluster-and-outlier-analysis",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#cluster-and-outlier-analysis",
    "title": "Hands-On Exercise 2",
    "section": "4.6 Cluster and Outlier Analysis",
    "text": "4.6 Cluster and Outlier Analysis\nLocal Indicators of Spatial Association (“LISA”) are statistics that evaluate the existence of clusters (and not clustering) in the spatial arrangement of a given variable.\nIn this section, we learn how to apply appropriate LISA, especially local Moran’I to detect cluster and/or outlier from GDP per capita 2012 of Hunan Province, PRC.\n\n4.6.1 Compute local Moran’s I\nThe Local Moran’s I statistic is relatively similar to the Global Moran’s Iin that it is providing a measure of how similar locations are to their neighbors. However, the difference is that each location, i, receive its own Ivalue, as well as its own variance, z value, expected I, and variance of I\nTo compute local Moran’s I, the localmoran() function of spdep will be used. The code chunks below are used to compute local Moran’s I of GDPPC2012 at the county level.\n\nfips <- order(hunan$County)\nlocalMI <- localmoran(hunan$GDPPC, rswm_q)\nhead(localMI)\n\n            Ii          E.Ii       Var.Ii        Z.Ii Pr(z != E(Ii))\n1 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\n2  0.025878173 -6.061953e-04 1.016664e-02  0.26266425      0.7928094\n3 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705      0.9843090\n4  0.001022468 -2.404783e-07 5.105969e-06  0.45259801      0.6508382\n5  0.014814881 -6.829362e-05 1.449949e-03  0.39085814      0.6959021\n6 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835      0.6331568\n\n\nlocalmoran() function returns a matrix of values whose columns are:\n\nIi: the local Moran’s I statistics\nE.Ii: the expectation of local moran statistic under the randomisation hypothesis\nVar.Ii: the variance of local moran statistic under the randomisation hypothesis\nZ.Ii:the standard deviate of local moran statistic\nPr(): the p-value of local moran statistic\n\nThe column on the far right provides the p-values (ignore the z>0 text and just think of these as p-values). We can relate these p-values to different confidence levels (e.g. 99%, 95%, etc.) in order to make a conclusion about the spatial distribution of attributes in ther dataset. \nThe code chunk below list the content of the local Moran matrix derived by using printCoefmat().\n\nprintCoefmat(data.frame(localMI[fips,], row.names=hunan$County[fips]), check.names=FALSE)\n\n                       Ii        E.Ii      Var.Ii        Z.Ii Pr.z....E.Ii..\nAnhua         -2.2493e-02 -5.0048e-03  5.8235e-02 -7.2467e-02         0.9422\nAnren         -3.9932e-01 -7.0111e-03  7.0348e-02 -1.4791e+00         0.1391\nAnxiang       -1.4685e-03 -2.8150e-05  4.7238e-04 -6.6269e-02         0.9472\nBaojing        3.4737e-01 -5.0089e-03  8.3636e-02  1.2185e+00         0.2230\nChaling        2.0559e-02 -9.6812e-04  2.7711e-02  1.2932e-01         0.8971\nChangning     -2.9868e-05 -9.0010e-09  1.5105e-07 -7.6828e-02         0.9388\nChangsha       4.9022e+00 -2.1348e-01  2.3194e+00  3.3590e+00         0.0008\nChengbu        7.3725e-01 -1.0534e-02  2.2132e-01  1.5895e+00         0.1119\nChenxi         1.4544e-01 -2.8156e-03  4.7116e-02  6.8299e-01         0.4946\nCili           7.3176e-02 -1.6747e-03  4.7902e-02  3.4200e-01         0.7324\nDao            2.1420e-01 -2.0824e-03  4.4123e-02  1.0297e+00         0.3032\nDongan         1.5210e-01 -6.3485e-04  1.3471e-02  1.3159e+00         0.1882\nDongkou        5.2918e-01 -6.4461e-03  1.0748e-01  1.6338e+00         0.1023\nFenghuang      1.8013e-01 -6.2832e-03  1.3257e-01  5.1198e-01         0.6087\nGuidong       -5.9160e-01 -1.3086e-02  3.7003e-01 -9.5104e-01         0.3416\nGuiyang        1.8240e-01 -3.6908e-03  3.2610e-02  1.0305e+00         0.3028\nGuzhang        2.8466e-01 -8.5054e-03  1.4152e-01  7.7931e-01         0.4358\nHanshou        2.5878e-02 -6.0620e-04  1.0167e-02  2.6266e-01         0.7928\nHengdong       9.9964e-03 -4.9063e-04  6.7742e-03  1.2742e-01         0.8986\nHengnan        2.8064e-02 -3.2160e-04  3.7597e-03  4.6294e-01         0.6434\nHengshan      -5.8201e-03 -3.0437e-05  5.1076e-04 -2.5618e-01         0.7978\nHengyang       6.2997e-02 -1.3046e-03  2.1865e-02  4.3486e-01         0.6637\nHongjiang      1.8790e-01 -2.3019e-03  3.1725e-02  1.0678e+00         0.2856\nHuarong       -1.5389e-02 -1.8667e-03  8.1030e-02 -4.7503e-02         0.9621\nHuayuan        8.3772e-02 -8.5569e-04  2.4495e-02  5.4072e-01         0.5887\nHuitong        2.5997e-01 -5.2447e-03  1.1077e-01  7.9685e-01         0.4255\nJiahe         -1.2431e-01 -3.0550e-03  5.1111e-02 -5.3633e-01         0.5917\nJianghua       2.8651e-01 -3.8280e-03  8.0968e-02  1.0204e+00         0.3076\nJiangyong      2.4337e-01 -2.7082e-03  1.1746e-01  7.1800e-01         0.4728\nJingzhou       1.8270e-01 -8.5106e-04  2.4363e-02  1.1759e+00         0.2396\nJinshi        -1.1988e-02 -5.3666e-03  1.1334e-01 -1.9667e-02         0.9843\nJishou        -2.8680e-01 -2.6305e-03  4.4028e-02 -1.3543e+00         0.1756\nLanshan        6.3334e-02 -9.6365e-04  2.0441e-02  4.4972e-01         0.6529\nLeiyang        1.1581e-02 -1.4948e-04  2.5082e-03  2.3422e-01         0.8148\nLengshuijiang -1.7903e+00 -8.2129e-02  2.1598e+00 -1.1623e+00         0.2451\nLi             1.0225e-03 -2.4048e-07  5.1060e-06  4.5260e-01         0.6508\nLianyuan      -1.4672e-01 -1.8983e-03  1.9145e-02 -1.0467e+00         0.2952\nLiling         1.3774e+00 -1.5097e-02  4.2601e-01  2.1335e+00         0.0329\nLinli          1.4815e-02 -6.8294e-05  1.4499e-03  3.9086e-01         0.6959\nLinwu         -2.4621e-03 -9.0703e-06  1.9258e-04 -1.7676e-01         0.8597\nLinxiang       6.5904e-02 -2.9028e-03  2.5470e-01  1.3634e-01         0.8916\nLiuyang        3.3688e+00 -7.7502e-02  1.5180e+00  2.7972e+00         0.0052\nLonghui        8.0801e-01 -1.1377e-02  1.5538e-01  2.0787e+00         0.0376\nLongshan       7.5663e-01 -1.1100e-02  3.1449e-01  1.3690e+00         0.1710\nLuxi           1.8177e-01 -2.4855e-03  3.4249e-02  9.9561e-01         0.3194\nMayang         2.1852e-01 -5.8773e-03  9.8049e-02  7.1663e-01         0.4736\nMiluo          1.8704e+00 -1.6927e-02  2.7925e-01  3.5715e+00         0.0004\nNan           -9.5789e-03 -4.9497e-04  6.8341e-03 -1.0988e-01         0.9125\nNingxiang      1.5607e+00 -7.3878e-02  8.0012e-01  1.8274e+00         0.0676\nNingyuan       2.0910e-01 -7.0884e-03  8.2306e-02  7.5356e-01         0.4511\nPingjiang     -9.8964e-01 -2.6457e-03  5.6027e-02 -4.1698e+00         0.0000\nQidong         1.1806e-01 -2.1207e-03  2.4747e-02  7.6396e-01         0.4449\nQiyang         6.1966e-02 -7.3374e-04  8.5743e-03  6.7712e-01         0.4983\nRucheng       -3.6992e-01 -8.8999e-03  2.5272e-01 -7.1814e-01         0.4727\nSangzhi        2.5053e-01 -4.9470e-03  6.8000e-02  9.7972e-01         0.3272\nShaodong      -3.2659e-02 -3.6592e-05  5.0546e-04 -1.4510e+00         0.1468\nShaoshan       2.1223e+00 -5.0227e-02  1.3668e+00  1.8583e+00         0.0631\nShaoyang       5.9499e-01 -1.1253e-02  1.3012e-01  1.6807e+00         0.0928\nShimen        -3.8794e-02 -3.8603e-04  6.4756e-03 -4.7729e-01         0.6332\nShuangfeng     9.2835e-03 -2.2867e-03  3.1516e-02  6.5174e-02         0.9480\nShuangpai      8.0591e-02 -3.1366e-04  8.9838e-03  8.5358e-01         0.3933\nSuining        3.7585e-01 -3.5933e-03  4.1870e-02  1.8544e+00         0.0637\nTaojiang      -2.5394e-01 -1.2395e-03  1.4477e-02 -2.1002e+00         0.0357\nTaoyuan        1.4729e-02 -1.2039e-04  8.5103e-04  5.0903e-01         0.6107\nTongdao        4.6482e-01 -6.9870e-03  1.9879e-01  1.0582e+00         0.2900\nWangcheng      4.4220e+00 -1.1067e-01  1.3596e+00  3.8873e+00         0.0001\nWugang         7.1003e-01 -7.8144e-03  1.0710e-01  2.1935e+00         0.0283\nXiangtan       2.4530e-01 -3.6457e-04  3.2319e-03  4.3213e+00         0.0000\nXiangxiang     2.6271e-01 -1.2703e-03  2.1290e-02  1.8092e+00         0.0704\nXiangyin       5.4525e-01 -4.7442e-03  7.9236e-02  1.9539e+00         0.0507\nXinhua         1.1810e-01 -6.2649e-03  8.6001e-02  4.2409e-01         0.6715\nXinhuang       1.5725e-01 -4.1820e-03  3.6648e-01  2.6667e-01         0.7897\nXinning        6.8928e-01 -9.6674e-03  2.0328e-01  1.5502e+00         0.1211\nXinshao        5.7578e-02 -8.5932e-03  1.1769e-01  1.9289e-01         0.8470\nXintian       -7.4050e-03 -5.1493e-03  1.0877e-01 -6.8395e-03         0.9945\nXupu           3.2406e-01 -5.7468e-03  5.7735e-02  1.3726e+00         0.1699\nYanling       -6.9021e-02 -5.9211e-04  9.9306e-03 -6.8667e-01         0.4923\nYizhang       -2.6844e-01 -2.2463e-03  4.7588e-02 -1.2202e+00         0.2224\nYongshun       6.3064e-01 -1.1350e-02  1.8830e-01  1.4795e+00         0.1390\nYongxing       4.3411e-01 -9.0735e-03  1.5088e-01  1.1409e+00         0.2539\nYou            7.8750e-02 -7.2728e-03  1.2116e-01  2.4714e-01         0.8048\nYuanjiang      2.0004e-04 -1.7760e-04  2.9798e-03  6.9181e-03         0.9945\nYuanling       8.7298e-03 -2.2981e-06  2.3221e-05  1.8121e+00         0.0700\nYueyang        4.1189e-02 -1.9768e-04  2.3113e-03  8.6085e-01         0.3893\nZhijiang       1.0476e-01 -7.8123e-04  1.3100e-02  9.2214e-01         0.3565\nZhongfang     -2.2685e-01 -2.1455e-03  3.5927e-02 -1.1855e+00         0.2358\nZhuzhou        3.2864e-01 -5.2432e-04  7.2391e-03  3.8688e+00         0.0001\nZixing        -7.6849e-01 -8.8210e-02  9.4057e-01 -7.0144e-01         0.4830\n\n\n\n4.6.1.1 Map the local Moran’s I\nBefore mapping the local Moran’s I map, we append the local Moran’s I dataframe (i.e. localMI) onto hunan SpatialPolygonDataFrame. The code chunks below can be used to perform the task. The SpatialPolygonDataFrame is called hunan.localMI.\n\nhunan.localMI <- cbind(hunan,localMI) %>%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\nUsing choropleth mapping functions of tmap package, we can plot the local Moran’s I values by using the code chinks below.\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"Local Moran statistics\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Local Moran's I Statistics\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n4.6.1.2 Map the local Moran’s I p-values\nThe choropleth shows there is evidence for both positive and negative Ii values. However, it is useful to consider the p-values for each of these values.\nThe code chunks below produce a choropleth map of Moran’s I p-values by using functions of tmap package\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\",\n          title = \"Local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Local Moran's I p-values\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\n\n\n\n\n\n4.6.1.3 Map both local Moran’s I values and p-values\n\nlocalMI.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"Local Moran statistics\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Local Moran's I statistics\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\npvalue.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"Local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Local Moran's I p-values\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette."
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#create-a-lisa-cluster-map",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#create-a-lisa-cluster-map",
    "title": "Hands-On Exercise 2",
    "section": "4.7 Create a LISA Cluster Map",
    "text": "4.7 Create a LISA Cluster Map\nThe LISA Cluster Map shows the significant locations color coded by type of spatial autocorrelation. The first step before we can generate the LISA cluster map is to plot the Moran scatterplot.\n\n4.7.1 Plot Moran scatterplot\nThe Moran scatterplot illustrates the relationship between the values of the chosen attribute at each location and the average value of the same attribute at neighboring locations.\nThe code chunk below plots the Moran scatterplot of GDPPC 2012 by using moran.plot() of spdep.\n\nnci <- moran.plot(hunan$GDPPC, rswm_q,\n                  labels=as.character(hunan$County), \n                  xlab=\"GDPPC 2012\", \n                  ylab=\"Spatially Lag GDPPC 2012\")\n\n\n\n\nNotice that the plot is split in 4 quadrants. The x-axis represents the values at location i, while the y-axis represents values in the neighborhood of location i. Therefore, values in the top-right of the scatterplot represent locations in which the attribute at i and its neighbors are well above the mean, indicating positive spatial autocorrelation. In the above, the top right corner belongs to areas that have high GDPPC and are surrounded by other areas that also have above average level of GDPPC (high-high spatial autocorrelation).\nPoints in the lower-left corner of the plot indicate locations in which the attribute at i and its neighbors are below the mean; this also represents locations of positive spatial autocorrelation because nearby locations are similar (low-low spatial autocorrelation) . In contrast, the lower-right and upper-left quadrant correspond to negative spatial autocorrelation (dissimilar values at neighboring locations and hence treated as outliers). We refer to them as respectively high-low and low-high spatial autocorrelation.\nThe solid diagonal line is a best-fit line through the points, indicating the presence of positive spatial autocorrelation throughout the entire dataset. Note that points represent with a diamond shape are values that are deemed to be significant at a specific level of confidence; the numbers next to these points simply represent their ID number. \n\n\n\n\n\n\nIt is important to keep in mind that the classification as such does not imply significance.\n\n\n\n\n\n\n\n\n4.7.2 Plot Moran scatterplot with standardised variable\nFirst we use scale() to centers and scales the variable. Here centering is done by subtracting the mean (omitting NAs) the corresponding columns, and scaling is done by dividing the (centered) variable by their standard deviations.\n\nhunan$Z.GDPPC <- scale(hunan$GDPPC) %>% as.vector \n\nThe as.vector() added to the end is to make sure that the data type we get out of this is a vector, that map neatly into out dataframe.\nNow, we are ready to plot the Moran scatterplot again by using the code chunk below.\n\nnci2 <- moran.plot(hunan$Z.GDPPC, rswm_q,\n                   labels=as.character(hunan$County),\n                   xlab=\"z-GDPPC 2012\", \n                   ylab=\"Spatially Lag z-GDPPC 2012\")\n\n\n\n\n\n\n4.7.3 Prepare the LISA map classes\nThe code chunks below show the steps to prepare a LISA cluster map.\n\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\n\nNext, we centers the variable of interest around its mean.\n\nhunan$lag_GDPPC <- lag.listw(rswm_q, hunan$GDPPC)\nDV <- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)          \n\nThis is follow by centering the local Moran’s around the mean.\n\nLM_I <- localMI[,1] - mean(localMI[,1])    \n\nNext, we will set a statistical significance level for the local Moran.\n\nsignif <- 0.05       \n\nThe following four command lines define the low-low (1), low-high (2), high-low (3) and high-high (4) categories.\n\n# LM_I > 0 => Positive Autocorrelation, DV < 0 => Low\n# Low-Low => Low and neighbors are Low\nquadrant[DV <0 & LM_I>0] <- 1 \n\n# LM_I<0 => Negative Autocorrelation, DV > 0 => High neigbors\n# Low-High => Low outlier among High neighbors\nquadrant[DV >0 & LM_I<0] <- 2\n\n# LM_I < 0 => Negative Autocorrelation, DV < 0 => Low neighors\n# High-Low => High outlier among Low neighbors\nquadrant[DV <0 & LM_I<0] <- 3  \n\n# LM_I > 0 => Positive Autocorrelation, DV > 0 => High\n# High - High => High and neighbors are High\nquadrant[DV >0 & LM_I>0] <- 4      \n\nLastly, places non-significant Moran in the category 0.\n\nquadrant[localMI[,5]>signif] <- 0\n\n\n\n4.7.4 Plot LISA map\nWe plot both the local Moran’s I values map and its corresponding p-values map next to each other.\n\ngdppc <- qtm(hunan, \"GDPPC\") +\n  tm_layout(main.title = \"2012 GDPPC of Hunan\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = \"LISA Map\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n  \n\ntmap_arrange(gdppc, LISAmap, asp=1, ncol=2)"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#hot-spot-and-cold-spot-area-analysis",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#hot-spot-and-cold-spot-area-analysis",
    "title": "Hands-On Exercise 2",
    "section": "4.8 Hot Spot and Cold Spot Area Analysis",
    "text": "4.8 Hot Spot and Cold Spot Area Analysis\nBeside detecting cluster and outliers, localised spatial statistics can be also used to detect hot spot and/or cold spot areas.\nThe term ‘hot spot’ has been used generically across disciplines to describe a region or value that is higher relative to its surroundings (Lepers et al 2005, Aben et al 2012, Isobe et al 2015).\n\n4.8.1 Getis and Ord’s G-Statistics\nAn alternative spatial statistics to detect spatial anomalies is the Getis and Ord’s G-statistics (Getis and Ord, 1972; Ord and Getis, 1995). It looks at neighbors within a defined proximity to identify where either high or low values clutser spatially. Here, statistically significant hot-spots are recognised as areas of high values where other areas within a neighborhood range also share high values too.\nThe analysis consists of three steps:\n\nDeriving spatial weight matrix\nComputing Gi statistics\nMapping Gi statistics\n\n\n\n4.8.2 Deriving distance-based weight matrix\nFirst, we need to define a new set of neighbors. Whist the spatial autocorrelation considered units which shared borders, for Getis-Ord we are defining neighbors based on distance.\nThere are two type of distance-based proximity matrix, they are:\n\nfixed distance weight matrix; and\nadaptive distance weight matrix.\n\n\n4.8.2.1 Deriving the centroid of each county\n(This is covered in Section 3.5.3.1 of In-Class Ex1)\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\ncoords <- cbind(longitude, latitude)\n\n\n\n4.8.2.2 Determine the cut-off distance\n(This is covered in Section 3.6.1 of In-Class Ex1)\n\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbor.\n\n\n4.8.2.3 Compute fixed distance weight matrix\n(This is covered in Section 3.6.2.1 of In-Class Ex1)\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\nNext, we use nb2listw() to convert the nb object into spatial weights object.\n\nwm62_lw <- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440\n\n\n\n\n\n4.8.3 Compute adaptive distance weight matrix\n(This is covered in Section 3.6.3 of In-Class Ex1)\nTo control the numbers of neighbors directly using k-nearest neighbors, we can tweak the k argument in the knearneigh() function.\n\nknn <- knn2nb(knearneigh(coords, k=8))\nknn\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\nNext, nb2listw() is used to convert the nb object into spatial weights object.\n\nknn_lw <- nb2listw(knn, style = 'B')\nsummary(knn_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014"
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#compute-gi-statistics",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#compute-gi-statistics",
    "title": "Hands-On Exercise 2",
    "section": "4.9 Compute Gi statistics",
    "text": "4.9 Compute Gi statistics\n\n4.9.1 Gi statistics using fixed distance\n\nfips <- order(hunan$County)\ngi.fixed <- localG(hunan$GDPPC, wm62_lw)\ngi.fixed\n\n [1]  0.436075843 -0.265505650 -0.073033665  0.413017033  0.273070579\n [6] -0.377510776  2.863898821  2.794350420  5.216125401  0.228236603\n[11]  0.951035346 -0.536334231  0.176761556  1.195564020 -0.033020610\n[16]  1.378081093 -0.585756761 -0.419680565  0.258805141  0.012056111\n[21] -0.145716531 -0.027158687 -0.318615290 -0.748946051 -0.961700582\n[26] -0.796851342 -1.033949773 -0.460979158 -0.885240161 -0.266671512\n[31] -0.886168613 -0.855476971 -0.922143185 -1.162328599  0.735582222\n[36] -0.003358489 -0.967459309 -1.259299080 -1.452256513 -1.540671121\n[41] -1.395011407 -1.681505286 -1.314110709 -0.767944457 -0.192889342\n[46]  2.720804542  1.809191360 -1.218469473 -0.511984469 -0.834546363\n[51] -0.908179070 -1.541081516 -1.192199867 -1.075080164 -1.631075961\n[56] -0.743472246  0.418842387  0.832943753 -0.710289083 -0.449718820\n[61] -0.493238743 -1.083386776  0.042979051  0.008596093  0.136337469\n[66]  2.203411744  2.690329952  4.453703219 -0.340842743 -0.129318589\n[71]  0.737806634 -1.246912658  0.666667559  1.088613505 -0.985792573\n[76]  1.233609606 -0.487196415  1.626174042 -1.060416797  0.425361422\n[81] -0.837897118 -0.314565243  0.371456331  4.424392623 -0.109566928\n[86]  1.364597995 -1.029658605 -0.718000620\nattr(,\"cluster\")\n [1] Low  Low  High High High High High High High Low  Low  High Low  Low  Low \n[16] High High High High Low  High High Low  Low  High Low  Low  Low  Low  Low \n[31] Low  Low  Low  High Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[46] High High Low  Low  Low  Low  High Low  Low  Low  Low  Low  High Low  Low \n[61] Low  Low  Low  High High High Low  High Low  Low  High Low  High High Low \n[76] High Low  Low  Low  Low  Low  Low  High High Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nThe Gi statistics is represented as a Z-score. Larger values represent a greater intensity of clustering and the direction (positive or negative) indicates high or low clusters.\nNext, we will join the Gi values to their corresponding hunan sf data frame by using the code chunk below.\n\nhunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\nThe code chunk above performs three tasks:\n\nFirst, it convert the output vector (i.e. gi.fixed) into r matrix object by using as.matrix().\nNext, cbind() is used to join hunan@data and gi.fixed matrix to produce a new SpatialPolygonDataFrame called hunan.gi.\nLastly, the field name of the gi values is renamed to gstat_fixed by using rename().\n\n\n\n4.9.2 Map Gi values with fixed distance weights\nThe code chunk below shows the functions used to map the Gi values derived using fixed distance weight matrix.\n\ngdppc <- qtm(hunan, \"GDPPC\") +\n            tm_layout(main.title = \"2012 GDPPC of Hunan\\n \",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\nGimap <-tm_shape(hunan.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5)  +\n  tm_layout(main.title = \"Local Gi Statistics\\n(Fixed Distance)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\ntmap_arrange(gdppc, Gimap, asp=1, ncol=2)\n\nVariable(s) \"gstat_fixed\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nHotspots from the local Gi chrolopleth map are almost in sync with the counties with highest GDPPC\n\n\n4.9.3 Gi statistics using adaptive distance\nThe code chunk below are used to compute the Gi values for GDPPC2012 by using an adaptive distance weight matrix (i.e knb_lw).\n\nfips <- order(hunan$County)\ngi.adaptive <- localG(hunan$GDPPC, knn_lw)\nhunan.gi <- cbind(hunan, as.matrix(gi.adaptive)) %>%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\n4.9.4 Map Gi values with adaptive distance weights\nIt is time for us to visualise the locations of hot spot and cold spot areas. The choropleth mapping functions of tmap package will be used to map the Gi values.\nThe code chunk below shows the functions used to map the Gi values derived using fixed distance weight matrix.\n\ngdppc<- qtm(hunan, \"GDPPC\") +\n            tm_layout(main.title = \"2012 GDPPC of Hunan\\n \",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\nGimap <- tm_shape(hunan.gi) + \n  tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\", \n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5)  +\n  tm_layout(main.title = \"Local Gi Statistics\\n(Adpative Distance)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\ntmap_arrange(gdppc, \n             Gimap, \n             asp=1, \n             ncol=2)\n\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette."
  },
  {
    "objectID": "Hands-On_Ex/Hands-on_Ex2.html#references",
    "href": "Hands-On_Ex/Hands-on_Ex2.html#references",
    "title": "Hands-On Exercise 2",
    "section": "4.10 References",
    "text": "4.10 References\n\nSpatial Autocorrelation: How spatial objects affect other nearby spatial objects\nSpatial Autocorrelation: How spatial objects affect other nearby spatial objects | by Anubhav Pattnaik | Locale | Medium\nHow Spatial Autocorrelation (Global Moran’s I) works\nHow Spatial Autocorrelation (Global Moran’s I) works—ArcGIS Pro | Documentation\nA basic introduction to Moran’s I analysis in R\nA basic introduction to Moran’s I analysis in R (mgimond.github.io)\nGlobal vs Local Spatial Autocorrelation\nGLOBAL VS LOCAL SPATIAL AUTOCORRELATION (arcgis.com)"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex1.html",
    "href": "In-Class_Ex/In-Class_Ex1.html",
    "title": "In-Class Exercise 1",
    "section": "",
    "text": "Learn how to:\n\nCompute spatial weights\nCalculate spatial lagged variables\n\nusing appropriate functions of spdep package.\n(Note: this above was part of an in-class exercise for ISSS624 conducted on 19 Nov 2022).\n\n\n\nTwo datasets are used in this exercise. They are:\n\nHunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\n\n\n\nThe code chunks below will install and load the 4 packages needed for this exericse.\n\npacman::p_load(sf, tidyverse, spdep, tmap) # wrapper for install and load library\n\n\n\n\n\n\nThe code chunk below will import ESRI shapefile into R\n\nhunan = st_read(dsn = \"In-Class_Ex1/data/geospatial\", \n                  layer = \"hunan\") # The dsn path is with reference to the .qmd document created to house this page\n\nReading layer `hunan' from data source \n  `C:\\Cabbie-UK\\ISSS624\\In-Class_Ex\\In-Class_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\n\nWe import Hunan_2012.csv into R by using read_csv() of readr package. The output is R dataframe class\n\nhunan2012 = read_csv(\"In-Class_Ex1/data/aspatial/Hunan_2012.csv\", show_col_types = FALSE) \n\nInspect the first rows of hunan2012\n\nhead(hunan2012)\n\n# A tibble: 6 × 29\n  County   City  avg_w…¹ depos…²   FAI Gov_Rev Gov_Exp    GDP GDPPC    GIO  Loan\n  <chr>    <chr>   <dbl>   <dbl> <dbl>   <dbl>   <dbl>  <dbl> <dbl>  <dbl> <dbl>\n1 Anhua    Yiya…   30544  10967  6832.    457.   2703  13225  14567  9277. 3955.\n2 Anren    Chen…   28058   4599. 6386.    221.   1455.  4941. 12761  4189. 2555.\n3 Anxiang  Chan…   31935   5517. 3541     244.   1780. 12482  23667  5109. 2807.\n4 Baojing  Huna…   30843   2250  1005.    193.   1379.  4088. 14563  3624. 1254.\n5 Chaling  Zhuz…   31251   8241. 6508.    620.   1947  11585  20078  9158. 4287.\n6 Changni… Heng…   28518  10860  7920     770.   2632. 19886  24418 37392  4243.\n# … with 18 more variables: NIPCR <dbl>, Bed <dbl>, Emp <dbl>, EmpR <dbl>,\n#   EmpRT <dbl>, Pri_Stu <dbl>, Sec_Stu <dbl>, Household <dbl>,\n#   Household_R <dbl>, NOIP <dbl>, Pop_R <dbl>, RSCG <dbl>, Pop_T <dbl>,\n#   Agri <dbl>, Service <dbl>, Disp_Inc <dbl>, RORP <dbl>, ROREmp <dbl>, and\n#   abbreviated variable names ¹​avg_wage, ²​deposite\n\n\n\n\n\nTo combine the information in the shapefile and the attribute data, we perform a left_join (from dplyr package) using the county name that is available under NAME_3 column of the Hunan shapefile and the County column n the Hunan attribute file\n\nhunan = left_join(hunan,hunan2012,\n                  by =c(\"NAME_3\"=\"County\"))\n\n\n\n\nWe prepare a basemap and a choropleth map showing the distribution of GDP per capita (GDPPC) 2012 by using qtm() of tmap package\n\nbasemap = tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.35) +\n  tm_layout(main.title = \"Basemap of Hunan province, China\",\n          main.title.position = \"center\",\n          main.title.size = 1.2)\n\ngdppc =qtm(hunan, fill = \"GDPPC\",\n          legend.height = 0.25, \n          legend.width = 0.35,\n          legend.outside = FALSE,\n          legend.position = c(\"right\", \"bottom\")\n          ) +\n          tm_layout(main.title = \"Distribution of GDPPC, 2012\",\n          main.title.position = \"center\",\n          main.title.size = 1.2)\n\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n\n\nWe will use poly2nb() of spdep package to compute contiguity weight matrices. The function builds a neighbours list based on regions with contiguous boundaries, that is sharing one or more boundary point. The function uses the Queen criteria by default (see section 3.5.3 to use the Rook criteria).\n\n\nTHe Queen method identifies neighbors that surround the area of study. In the diagram below, the blue cell i, is surrounded by 8 neighbors\n\n\n\n\n\nThe code chunk below is used to compute Queen contiguity weight matrix.\n\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nThe summary report above shows that there are 88 area units in Hunan.\nThere are two area units - regions 30 and 65 - with only one neighbor.\nThe most connected area unit - region 85 - has 11 neighbors.\n\n\nFor example, to see the neighbors for the first polygon in the object, type:\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\nPolygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.\n\n\n\nWe can use the following code chunk below:\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\n\n\n\nWe can use the following code chunk:\n\nhunan$NAME_3[wm_q[[1]]]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\nor\n\nhunan$NAME_3[c(2,3,4,57,85)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\n\n\n\nWe can use the code chunk below.\n\nnb1 = wm_q[[1]]\nnb1 = hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\n\n\n\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n\n\n\n\n\n\nThe Rook method identifies adjacent neighbors. In the diagram below, the blue cell i has 4 neighbors, much like how a Rook moves about on a chess board.\n\n\n\n\n\nThe code chunk below is used to compute Rook contiguity weight matrix.\n\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\nThe summary report above shows that there are 88 area units in Hunan. Similar to the Queen’s method, the most connected area unit - Region 85 - has 10 neighbors. Two area units - Regions 30 and 65 - only have 1 neighbor.\n\n\n\nA connectivity graph takes a point and displays a line to each neighboring point. For polygons, we will typically use the polygon centroids as the connecting points.\n\n\nTo do so, we will use a mapping function to apply the st_centroid method on the geometry column of each area unit/county.\nTo get the longitude values, we map the st_centroid function over the geometry column of hunan and access the longitude value through double bracket notation [[]] and 1. This allows us to get only the longitude, which is the first value in each centroid.\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nTo get the latitude, we access the second value in each centroid.\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nWe then combine the longitude and latitude values into a data frame object\n\ncoords = cbind(longitude,latitude)\n\nWe check the first few observations to see if the values are formatted correctly.\n\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n\n\n\n\n\n\n# Plot the base layer\nplot(hunan$geometry, border=\"lightgrey\") \n# Add on the connectivity layer\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\ntitle(main=\"Queen Contiguity\")\n\n\n\n# pch refers to the point symbol (dot)\n# cex refers to the point size\n\n\n\n\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"blue\")\ntitle(main=\"Rook Contiguity\")\n\n\n\n\n\n\n\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\ntitle(main=\"Queen Contiguity\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"blue\")\ntitle(main=\"Rook Contiguity\")\n\n\n\n\n\n\n\n\n\nWe will use the dnearneigh() of spdep package to derive distance-based weight matrices . The function identifies neighbours of region points by Euclidean distance with a distance band with lower distance bound (d1), and upper distance bound (d2).\n\n\nWe need to determine the upper limit for distance band by using the steps below so that all area units will have at least 1 neighbor:\n\nReturn a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using knearneigh() of spdep. By default k=1 and we can set this argument value explicitly.\nConvert the knn object returned by knearneigh() into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using knn2nb().\nReturn the length of neighbour relationship edges by using nbdists() of spdep. The function returns the Euclidean distances along the links in a list of the same form as the neighbors list.\nRemove the list structure of the returned object by using unlist().\n\n\n# Covers the first 2 points above to prepare a list of nearest neighbor for each area unit\nk1 = knn2nb(knearneigh(coords,k=1))\n\n# Covers the 3rd and 4th point above to return a vecotor of distances between the area unit and its nearest neighbor\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\n\n#Summarise the results\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbor distance is 61.79 km. This will be used as the upper threshold to provide certainty that all units will have at least one neighbor.\n\n\n\n\n\n\nwm_d62 = dnearneigh(coords, 0, 62, longlat = TRUE) # longlat = TRUE if point coordinates are geographical longitude-latitude decimal degrees, in which case distances are measured in kilometers\n\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\nBased on the above, within a distance of 62 km for each area unit, the average number of links or connections that the area units have is 3.7.\n\n\n\n\nstr(wm_d62)\n\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n\n\n\n\n\nThe function card(nb) is used to extract the number of neighbors from a “nb” object. The table function tabulates the count results\n\ntable(hunan$County, card(wm_d62))\n\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n\n\n\n# n.comp.nb() finds the number of disjoint connected subgraphs in the graph depicted by a spatial neighbours list object (or nb.obj)\nn_comp <- n.comp.nb(wm_d62)\n\n# nc column shows the number of disjoint connected subgraphs\nn_comp$nc\n\n[1] 1\n\n\n\n# comp.id contains a vector with the indices of the disjoint connected subgraphs that the nodes in nb.obj belong to\ntable(n_comp$comp.id)\n\n\n 1 \n88 \n\n\n\n\n\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\ntitle(main = \"Fixed Distance Weight Matrix Plot\")\n\n\n\n\nNote: The red links show that nearest neighbor for each area unit, while the black links show the additional neighbors if we set a distance buffer (or cut-off) of 62km.\nAlternatively, we can plot the 2 sets of links separately with the nearest neighbor being a subset of the distance linked areas.\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\ntitle(main = \"1st nearest neighbours\")\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)\ntitle(main = \"Distance-linked neighbours \\n (within 62km)\")\n\n\n\n\n\n\n\n\nTo control the numbers of neighbors directly using k-nearest neighbors, we can tweak the k argument in the knearneigh() function.\n\nknn6 <- knn2nb(knearneigh(coords, k=6))\nknn6\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\nSimilarly, we can display the content of the matrix by using str() and note that each county has exactly 6 neighbors.\n\nstr(knn6)\n\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n\n\n\n\nWe can run the following codes\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\ntitle(main = \"Disance-based Neighbours \\n (with k = 6)\")\n\n\n\n\n\n\n\n\n\nFirst, we compute the distances between areas (defined by Queen contiguity discussed in section 3.5.3.2) using nbdists() of spdep.\n\n# Compute the inverse of distances between a county and its neighbors\ndist <- nbdists(wm_q, coords, longlat = TRUE)\nids <- lapply(dist, function(x) 1/(x))\n\n# Display first 6 rows of ids\nhead(ids)\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n[[4]]\n[1] 0.01820896 0.02822040 0.03414741 0.01539065\n\n[[5]]\n[1] 0.03695795 0.03414741 0.01524598 0.01618354\n\n[[6]]\n[1] 0.015390649 0.015245977 0.021748129 0.011883901 0.009810297\n\n\n\n\nNext, we need to assign weights to each neighboring polygon using the nb2listw() function. In our case, each neighboring polygon is assigned equal weight (style=“W”) for simplicity’s sake. This is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values. While this is the most intuitive way to summaries the neighbors’ values it has one drawback in that polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data. Note that other more robust options are available, notably style=“B”.\n\n#zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in the dataset\n# Coding style = \"W\" means row standardisation is used\nrswm_q <- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nThe input of nb2listw() must be an object of class nb. The syntax of the function has two major arguments, namely style and zero.poly.\n\nstyle can take values “W”, “B”, “C”, “U”, “minmax” and “S”. B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).\nIf zero policy is set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row t(rep(0, length=length(neighbours))) %*% x, for arbitrary numerical vector x of length length(neighbours). The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.\n\nRecall that in Section 3.5.1.1 , Polygon 1 has 5 neighbors\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\nTo see the weights of the 5 neighbors:\n\nrswm_q$weights[[1]]\n\n[1] 0.2 0.2 0.2 0.2 0.2\n\n\nEach neighbor is assigned a 0.2 of the total weight. This means that when R computes the average neighboring income values, each neighbor’s income will be multiplied by 0.2 before being tallied.\nUsing the same method, we can also derive a row standardised distance weight matrix (based on Inversed Distance) by using the code chunk below.\n\nrswm_ids <- nb2listw(wm_q, glist=ids, style=\"B\", zero.policy=TRUE)\nrswm_ids\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n\n\nTo see the distance weights of the 5 neighbors for Polygon 1:\n\nrswm_ids$weights[[1]]\n\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n\nSummary of the distance weights\n\nsummary(unlist(rswm_ids$weights))\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338 \n\n\n\n\n\n\nThe lag.listw() function (from spdep package) uses a “listw” sparse representation of a spatial weights matrix to compute the lag vector Vx. A listw object is typically created by nb2listw() function.\n\n\nWe compute the average neighbor GDPPC value for each polygon. These values are often referred to as spatially lagged values.\n\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nWe can append the spatially lag GDPPC values onto hunan sf data frame by using the code chunk below.\n\n# Convert 2 separate lists into a list of lists\nlag.list = list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\n# Convert lag.list to a dataframe lag.res\nlag.res = as.data.frame(lag.list)\n# Rename the 2 columns in lag.res table\ncolnames(lag.res) = c(\"NAME_3\", \"lag GDPPC\")\n# Join lag.res wtih hunan\nhunan <- left_join(hunan,lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nThe following table shows the average neighboring income values (stored in the Inc.lag object) for the first 6 counties\n\nhead(hunan)\n\nSimple feature collection with 6 features and 36 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp lag GDPPC\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262  24847.20\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756  22724.80\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757  24143.25\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558  27737.50\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065  27270.25\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n\n\nNext, we plot both the GDPPC and spatial lag GDPPC for comparison using the code chunk below.\n\ngdppc =  qtm(hunan, \"GDPPC\") +\n          tm_layout(main.title = \"Distribution of GDPPC, 2012 \\n   \",\n          main.title.position = \"center\",\n          main.title.size = 1.2,\n          legend.height = 0.26, \n          legend.width = 0.40)\n\n\nlag_gdppc = qtm(hunan, \"lag GDPPC\") +\n            tm_layout(main.title = \"Distribution of Lag GDPPC, 2012 \\n (Row Standardised)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n\nWe can calculate spatial lag as a sum of neighboring values by assigning binary weights. This requires us to go back to our neighbors list, then apply a function that will assign binary weights, then we use glist = in the nb2listw function to explicitly assign these weights.\nWe start by applying a function that will assign a value of 1 per each neighbor. This is done with lapply, which we have been using to manipulate the neighbors structure throughout the past notebooks. Basically it applies a function across each value in the neighbors structure.\n\nb_weights <- lapply(wm_q, function(x) 0*x + 1)\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nWith the proper weights assigned, we use lag.listw() to compute a lag variable from our weight and GDPPC.\n\nlag_sum = list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res = as.data.frame(lag_sum)\ncolnames(lag.res) = c(\"NAME_3\", \"lag_sum GDPPC\")\n\nWe examine the results by using the code chunk below.\n\nlag_sum\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nWe append the lag_sum GDPPC field into hunan sf data frame by using the code chunk below.\n\nhunan <- left_join(hunan, lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nFinally, we plot both the GDPPC and Spatial Lag Sum GDPPC for comparison using the code chunk below.\n\ngdppc =   qtm(hunan, \"GDPPC\")+\n          tm_layout(main.title = \"Distribution of GDPPC, 2012 \\n   \",\n          main.title.position = \"center\",\n          main.title.size = 1.2,\n          legend.height = 0.26, \n          legend.width = 0.40)\n\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\") + \n            tm_layout(main.title = \"Distn of Lag_Sum GDPPC, 2012\\n(sum of neighboring values)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)  \n          \ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element (the data points for the county itself) before assigning weights.\n\nWe first assign wm_q to a new variable because we will directly alter its structure to add the diagonal elements.\n\nwm_q1 <- wm_q\n\nTo add the diagonal element to the neighbour list, we just need to use include.self() from spdep.\n\ninclude.self(wm_q1)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\n\nWe obtain the new weights with nb2listw()\n\nwm_q1 <- nb2listw(wm_q1)\nwm_q1\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nAgain, we create the lag variable from our weight structure and GDPPC variable.\n\nlag_w_avg_gpdpc <- lag.listw(wm_q1, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nThe code chunk below will be used to append lag_window_avg GDPPC values onto hunan sf data.frame by using left_join() of dplyr package.\n\nlag.list.wm_q1 <- list(hunan$NAME_3, lag.listw(wm_q1, hunan$GDPPC))\nlag_wm_q1.res <- as.data.frame(lag.list.wm_q1)\ncolnames(lag_wm_q1.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\nhunan <- left_join(hunan, lag_wm_q1.res)\n\nJoining, by = \"NAME_3\"\n\n\nWe use qtm() of tmap package is used to plot the GDPPC and lag_window_avg GDPPC map next to each other for quick comparison.\n\ngdppc =   qtm(hunan, \"GDPPC\")+\n          tm_layout(main.title = \"Distribution of GDPPC, 2012 \\n   \",\n          main.title.position = \"center\",\n          main.title.size = 1.2,\n          legend.height = 0.26, \n          legend.width = 0.40)\n\nw_avg_gdppc = qtm(hunan, \"lag_window_avg GDPPC\") + \n            tm_layout(main.title = \"Distn of Lag_Window Avg GDPPC\\n(row-std wghts plus diagonal element)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)  \n\ntmap_arrange(gdppc, w_avg_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n\nThe spatial window sum is the counterpart of the window average, but without using row-standardized weights. To do this we assign binary weights to the neighbor structure that includes the diagonal element.\n\nwm_q2 <- wm_q\n\nTo add the diagonal element to the neighbour list, we just need to use include.self() from spdep.\n\ninclude.self(wm_q2)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\n\nNext, we assign binary weights to the neighbor structure that includes the diagonal element.\n\nb_weights3 <- lapply(wm_q2, function(x) 0*x + 1)\nb_weights3[1]\n\n[[1]]\n[1] 1 1 1 1 1\n\n\nWe use nb2listw() and glist() to explicitly assign weight values.\n\nb_weights4 <- nb2listw(wm_q2, \n                       glist = b_weights3, \n                       style = \"B\")\nb_weights4\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nWith the new weight structure, we can compute the lag variable with lag.listw().\n\nw_sum_gdppc = list(hunan$NAME_3, lag.listw(b_weights4, hunan$GDPPC))\nw_sum_gdppc\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nThe code chunk below will be used to append w_sum GDPPC values onto hunan sf data.frame by using left_join() of dplyr package.\n\nw_sum_gdppc.res = as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\nhunan <- left_join(hunan, w_sum_gdppc.res)\n\nJoining, by = \"NAME_3\"\n\n\nWe use qtm() of tmap package to plot the GDPPC and lag_sum GDPPC map next to each other for quick comparison.\n\ngdppc =  qtm(hunan, \"GDPPC\") +\n          tm_layout(main.title = \"Distribution of GDPPC, 2012 \\n   \",\n          main.title.position = \"center\",\n          main.title.size = 1.2,\n          legend.height = 0.26, \n          legend.width = 0.40)\n\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\") + \n            tm_layout(main.title = \"Distn of Lag_sum GDPPC\\n(lag sum plus diagonal element)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)  \n\ntmap_arrange(gdppc, w_sum_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html",
    "href": "In-Class_Ex/In-Class_Ex2.html",
    "title": "In-Class Exercise 2",
    "section": "",
    "text": "Published on: 27-Nov-2022\n(First published on: 26-Nov-2022)"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#overview",
    "href": "In-Class_Ex/In-Class_Ex2.html#overview",
    "title": "In-Class Exercise 2",
    "section": "1.1 Overview",
    "text": "1.1 Overview\nTo prepare for the Take-home Exercise 1, which examines the spatial patterns of functional and non-functional water points (wp) in Nigeria\nLearn how to:\n\nImport raw Geospatial Data downloaded from the Internet\nPerform data wrangling for spatial pattern analysis"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#import-and-load-the-appropriate-packages-into-r-environment",
    "href": "In-Class_Ex/In-Class_Ex2.html#import-and-load-the-appropriate-packages-into-r-environment",
    "title": "In-Class Exercise 2",
    "section": "1.2 Import and load the appropriate packages into R environment",
    "text": "1.2 Import and load the appropriate packages into R environment\n\n# funModelling will be used for rapid Exploratory Data Analysis\npacman::p_load(sf, tidyverse, tmap, spdep, funModeling)"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#import-the-geospatial-data",
    "href": "In-Class_Ex/In-Class_Ex2.html#import-the-geospatial-data",
    "title": "In-Class Exercise 2",
    "section": "1.3 Import the Geospatial Data",
    "text": "1.3 Import the Geospatial Data\n2 geospatial data sets are used for this exericse:\n\ngeo_export: This contains information on the water points in Nigeria\nnga_lga2: This contains Nigeria Level-2 Administrative Boundary (also known as Local Government Area) polygon features GIS data\n\n\n1.3.1 Import water point geospatial data\n\nwp = st_read(dsn = \"In-Class_Ex2/geodata\",\n              layer = \"geo_export\",\n              crs = 4326) %>%\n  filter(clean_coun == \"Nigeria\")\n\nNext, write_rds() of readr package is used to save the extracted sf data table (i.e. wp) into an output file in rds data format. The output file is called wp_nga.rds and it is saved in geodata sub-folder.\n\nwrite_rds(wp, \"In-Class_Ex2/geodata/wp_nga.rds\")\n\n\n\n1.3.2 Import Nigeria LGA boundary data\n\nnga = st_read(dsn = \"In-Class_Ex2/geodata\",\n               layer = \"nga_lga2\",\n               crs = 4326)"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#data-wrangling",
    "href": "In-Class_Ex/In-Class_Ex2.html#data-wrangling",
    "title": "In-Class Exercise 2",
    "section": "2.1 Data Wrangling",
    "text": "2.1 Data Wrangling\n\n2.1.1 Recode NA values into string\nFirst, we do a count of the values in the status_cle column in the imported wp dataset\n\nwp_nga = read_rds(\"In-Class_Ex2/geodata/wp_nga.rds\")\n\nfreq(data=wp_nga,input = 'status_cle')\n\nWe use the replace_na() method to recode all the NA values in status_cle field into Unknown\n\nwp_nga = wp_nga %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#extract-functional-water-points",
    "href": "In-Class_Ex/In-Class_Ex2.html#extract-functional-water-points",
    "title": "In-Class Exercise 2",
    "section": "2.2 Extract functional water points",
    "text": "2.2 Extract functional water points\nIn the code chunk below, filter() of dplyr is used to select functional water points.\n\nwpt_functional = wp_nga %>%\n  filter(status_cle %in%\n           c(\"Functional\", \n             \"Functional but not in use\",\n             \"Functional but needs repair\"))"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#extract-non-functional-water-points",
    "href": "In-Class_Ex/In-Class_Ex2.html#extract-non-functional-water-points",
    "title": "In-Class Exercise 2",
    "section": "2.3 Extract non-functional water points",
    "text": "2.3 Extract non-functional water points\n\nwpt_nonfunctional = wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#extract-water-points-with-unknown-value",
    "href": "In-Class_Ex/In-Class_Ex2.html#extract-water-points-with-unknown-value",
    "title": "In-Class Exercise 2",
    "section": "2.4 Extract water points with Unknown value",
    "text": "2.4 Extract water points with Unknown value\n\nwpt_unknown = wp_nga %>%\n  filter(status_cle == \"Unknown\")"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#perform-point-in-polygon-count",
    "href": "In-Class_Ex/In-Class_Ex2.html#perform-point-in-polygon-count",
    "title": "In-Class Exercise 2",
    "section": "2.5 Perform Point-in-Polygon Count",
    "text": "2.5 Perform Point-in-Polygon Count\nWe use st_intersects to compute the number of functional, non-functional and unknown wps in each LGA.\n\nnga_wp = nga %>% \n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nga, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional))) %>%\n  mutate(`wpt unknown` = lengths(\n    st_intersects(nga, wpt_unknown)))"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#save-the-data-table-for-spatial-analysis",
    "href": "In-Class_Ex/In-Class_Ex2.html#save-the-data-table-for-spatial-analysis",
    "title": "In-Class Exercise 2",
    "section": "2.6 Save the data table for spatial analysis",
    "text": "2.6 Save the data table for spatial analysis\nWe derive two fields namely pct_functional and pct_non-functional using the mutate() of dplyr package. To keep the file size small, we use select() of dplyr is used to retain only columns 3,4,9,10, 18,19,20,21,22,and 23.\n\nnga_wp = nga_wp %>%\n  mutate(pct_functional = `wpt functional`/`total wpt`) %>%\n  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`) %>%\n  select(3:4, 9:10, 18:23)\n\nThereafter ,we save the tidied sf data table into rds format for our spatial analysis\n\nwrite_rds(nga_wp, \"In-Class_Ex2/geodata/nga_wp.rds\")"
  },
  {
    "objectID": "In-Class_Ex/In-Class_Ex2.html#visualise-the-spatial-dsitribution-of-water-points",
    "href": "In-Class_Ex/In-Class_Ex2.html#visualise-the-spatial-dsitribution-of-water-points",
    "title": "In-Class Exercise 2",
    "section": "2.7 Visualise the spatial dsitribution of water points",
    "text": "2.7 Visualise the spatial dsitribution of water points\n\n# Load the nga_wp sf data file prepare in the previous steps\nnga_wp <- read_rds(\"In-Class_Ex2/geodata/nga_wp.rds\")\n\n# Plot the various types of water points\ntotal = qtm(nga_wp, \"total wpt\") + \n        tm_layout(main.title = \"Total no. of \\nwater points\",\n                  main.title.position = \"center\",\n                  main.title.size = 1.0,\n                  legend.height = 0.26,\n                  legend.width = 0.40) \n\nwp_functional = qtm(nga_wp, \"wpt functional\") + \n                tm_layout(main.title = \"Total no. of functional \\nwater points\",\n                  main.title.position = \"center\",\n                  main.title.size = 1.0,\n                  legend.height = 0.26,\n                  legend.width = 0.40) \n\nwp_nonfunctional = qtm(nga_wp, \"wpt non-functional\") + \n                tm_layout(main.title = \"Total no. of non-functional \\nwater points\",\n                  main.title.position = \"center\",\n                  main.title.size = 1.0,\n                  legend.height = 0.26,\n                  legend.width = 0.40)\n\nunknown <- qtm(nga_wp, \"wpt unknown\") + \n                tm_layout(main.title = \"Total no. of  water points \\nwith unknown status\",\n                  main.title.position = \"center\",\n                  main.title.size = 1.0,\n                  legend.height = 0.26,\n                  legend.width = 0.40)\n\ntmap_arrange(total, wp_functional, wp_nonfunctional, unknown, ncol=2)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Applied Geospatial Analytics",
    "section": "",
    "text": "On this webpage, I am going to share my learning journey on geospatial analytics. This involves the transformation, manipulation and application of analytical methods to spatial (geographic) data.\nThe power of geospatial analysis is best exemplified by Dr. John Snow (15 March 1813 – 16 June 1858), an English physician in the development of anesthesia and medical hygiene. While investigating the Cholera outbreak in London in 1854, Snow used a dot map (see below) to represent the cluster of cholera cases around a pump which was the source of sewage-contaminated water.\n\nHe also used statistics to illustrate the connection between the quality of the water source and cholera cases. He showed that homes supplied by the Southwark and Vauxhall Waterworks Company, which was taking water from sewage-polluted sections of the Thames, had a cholera rate 14 times that of those supplied by Lambeth Waterworks Company, which obtained water from the upriver, cleaner Seething Wells. These supported his chemical and microscopic examination of the water collected from the pump was hazardous and convinced the local council to disable the well pump. This action was commonly credited as ending the Cholera outbreak.\nSnow’s study was a major event in the history of public health and geography\n(Source: John Snow - Wikipedia)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1.html",
    "href": "Take-home_Ex/Take-home_Ex1.html",
    "title": "Take-home Exercise 1",
    "section": "",
    "text": "First published on:"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1.html#overview",
    "href": "Take-home_Ex/Take-home_Ex1.html#overview",
    "title": "Take-home Exercise 1",
    "section": "1 Overview",
    "text": "1 Overview\n\n1.1 Setting the Scene\nWater is an important resource to mankind. Clean and accessible water is critical to human health. It provides a healthy environment, a sustainable economy, reduces poverty and ensures peace and security. Yet over 40% of the global population does not have access to sufficient clean water. By 2025, 1.8 billion people will be living in countries or regions with absolute water scarcity, according to UN-Water. The lack of water poses a major threat to several sectors, including food security. Agriculture uses about 70% of the world’s accessible freshwater.\nDeveloping countries are most affected by water shortages and poor water quality. Up to 80% of illnesses in the developing world are linked to inadequate water and sanitation. Despite technological advancement, providing clean water to the rural community is still a major development issue in many countries globally, especially in Africa.\nTo provide clean and sustainable water supply to the rural community, a global Water Point Data Exchange (WPdx) project was initiated. The main aim of this initiative is to collect water point related data from rural areas at the water point or small water scheme level and share the data via WPdx Data Repository, a cloud-based data library. The data is collected based on WPDx Data Standard.\n\n\n1.2 Objectives\nGeospatial analytics hold tremendous potential to address complex problems facing society.\nIn this study, we will apply appropriate global and local measures of spatial association techniques to reveal the spatial patterns of non-functional water points in Nigeria.\n\n\n1.3 The Data\nGeospatia data\nFor this assignment, 2 data sets will be used.\n\ngeo_export: It contains information on the water points in Nigeria. The data is available from WPdx Global Data Repositories and we are using the WPdx+ data set. The data is extracted in shapefile format.\n\nnga_lga2: The contains Nigeria Level-2 Administrative Boundary (also known as Local Government Area (LGA)) polygon features GIS data will be used. The data can be downloaded from The Humanitarian Data Exchange portal\n\n\n\n1.4 The Tasks\nThe specific tasks of this assignments are:\n\nUsing appropriate sf method, import the shapefiles into R and save it in a simple feature data frame format. The Projected Coordinate Systems of Nigeria, EPSG: 26391 is used\nUsing appropriate tidyr and dplyr methods, derive the proportion of functional and non-functional water point at LGA level.\nCombining the geospatial data frames into a Simple Feature (sf) data frame.\nPerforming outliers/clusters analysis by using appropriate local measures of spatial association methods.\nPerforming hotspot areas analysis by using appropriate local measures of spatial association methods.\n\n\n\n1.5 Thematic Mapping\n\nPlot maps to show the spatial distribution of functional and non-functional water point rate at LGA level by using appropriate thematic mapping technique provided by tmap package.\n\n\n\n1.6 Analytical Mapping\n\nPlot hotspot areas and outliers/clusters maps of functional and non-functional water point rate at LGA level by using appropriate thematic mapping technique provided by tmap package."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1.html#setup",
    "href": "Take-home_Ex/Take-home_Ex1.html#setup",
    "title": "Take-home Exercise 1",
    "section": "2 Setup",
    "text": "2 Setup\n\n2.1 Import and load relevant packages into R environment\nThe R packages we’ll use for this analysis are:\n\nsf: used for importing, managing, and processing geospatial data\ntidyverse: a collection of packages for data manipulation, visualisation and other science related tasks\ntmap: used for creating thematic maps, such as choropleth and bubble maps\nspdep: used to create spatial weights matrix objects and related calculations (e.g. spatially lag attributes)\nfunModeling: a library for rapid Exploratory Data Analysis\n\n\npacman::p_load(sf, tidyverse, tmap, spdep, funModeling, units)\n\n\n\n2.2 Import the Geospatial data sets\n\n2.2.1 Import water point geospatial data\nWe import the geo_export shapefile using st_read() of sf library and use filter() of the dplyr package to extract water point records in Nigeria\n\nwp = st_read(dsn = \"Take-home_Ex1/geodata\",\n              layer = \"geo_export\",\n              crs = 4326) %>%\n  filter(clean_coun == \"Nigeria\")\n\n\n\n\n\n\n\nWe do not transform the geographic data at this point as we will be using st_intersects() in a later step to process the data. This is because st_intersects() only works correctly if the geospatial data are in geographic coordinate system (i.e. wgs84)\n\n\n\n\n\n\nNext, write_rds() of readr package is used to save the extracted sf data table (i.e. wp) into an output file in rds data format. The output file is called wp_nga.rds and it is saved in geodata sub-folder.\n\nwrite_rds(wp, \"Take-home_Ex1/geodata/wp_nga.rds\")\n\n\n\n2.2.2 Import Nigeria LGA boundary data\nWe use st_read() to import the LGA boundary data into sf data table\n\nnga = st_read(dsn = \"Take-home_Ex1/geodata\",\n               layer = \"nga_lga2\",\n               crs = 4326)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1.html#data-wrangling",
    "href": "Take-home_Ex/Take-home_Ex1.html#data-wrangling",
    "title": "Take-home Exercise 1",
    "section": "3 Data Wrangling",
    "text": "3 Data Wrangling\n\n3.1 Recode the values in the status_cle column\nThe status_cle column in the wp_nga.rds file indicates the status of the water point when it was last assessed.\nWe do a count of the values in the status_cle column using freq() of the funModeling package.\n\nwp_nga = read_rds(\"Take-home_Ex1/geodata/wp_nga.rds\")\n\nfreq(data=wp_nga,input = 'status_cle')\n\n\nGiven that our objective is to examine spatial patterns of non-functional water points in Nigeria, we need to first compute the total number of functional, non-functional and blank value (denoted by “NA”) water points before we can derive the proportion of non-functional and functional water points.\nTo do so, we perform the following steps:\n\nWe use the replace_na() method to recode all the NA values in status_cle column into Unknown\n\nwp_nga = wp_nga %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\nWe use filter() of dplyr to create data tables which group (i) functional, (2) non functional and (3) water points with unknown status together\n\n# Extract functional water points\nwpt_functional = wp_nga %>%\n  filter(status_cle %in%\n           c(\"Functional\", \n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n\n# Extract non-functional water points\nwpt_nonfunctional = wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))\n\n# Extract water points with Unknown value\nwpt_unknown = wp_nga %>%\n  filter(status_cle == \"Unknown\")\n\n\n\n\n3.2 Perform Point-in-Polygon Count\nWe use st_intersects() of sf package to compute the number of functional, non-functional and unknown status water points in each LGA.\n\nnga_wp = nga %>% \n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nga, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional))) %>%\n  mutate(`wpt unknown` = lengths(\n    st_intersects(nga, wpt_unknown)))\n\n\n\n3.3 Save the data table for spatial analysis\nWe derive two fields namely pct_functional and pct_non-functional using the mutate() of dplyr package. To keep the file size small, we use select() of dplyr is used to retain only columns 3,4,9,10, 18,19,20,21,22,and 23.\n\nnga_wp = nga_wp %>%\n  mutate(pct_functional = `wpt functional`/`total wpt`) %>%\n  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`) %>%\n  select(3:4, 9:10, 18:23)\n\nThereafter ,we save the tidied sf data table into rds format for our spatial analysis\n\nwrite_rds(nga_wp, \"Take-home_Ex1/geodata/nga_wp.rds\")\n\n\n\n3.4 Visualise the spatial distribution of water points\n\n# Load the nga_wp sf data file prepare in the previous steps\nnga_wp <- read_rds(\"Take-home_Ex1/geodata/nga_wp.rds\")\n\n# Plot the various types of water points\ntotal = qtm(nga_wp, \"total wpt\") + \n        tm_layout(main.title = \"Total no. of \\nwater points\",\n                  main.title.position = \"center\",\n                  main.title.size = 1.0,\n                  legend.height = 0.26,\n                  legend.width = 0.40) \n\nwp_functional = qtm(nga_wp, \"wpt functional\") + \n                tm_layout(main.title = \"Total no. of functional \\nwater points\",\n                  main.title.position = \"center\",\n                  main.title.size = 1.0,\n                  legend.height = 0.26,\n                  legend.width = 0.40) \n\nwp_nonfunctional = qtm(nga_wp, \"wpt non-functional\") + \n                tm_layout(main.title = \"Total no. of non-functional \\nwater points\",\n                  main.title.position = \"center\",\n                  main.title.size = 1.0,\n                  legend.height = 0.26,\n                  legend.width = 0.40)\n\nunknown <- qtm(nga_wp, \"wpt unknown\") + \n                tm_layout(main.title = \"Total no. of  water points \\nwith unknown status\",\n                  main.title.position = \"center\",\n                  main.title.size = 1.0,\n                  legend.height = 0.26,\n                  legend.width = 0.40)\n\ntmap_arrange(total, wp_functional, wp_nonfunctional, unknown, ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1.html#data-processing",
    "href": "Take-home_Ex/Take-home_Ex1.html#data-processing",
    "title": "Take-home Exercise 1",
    "section": "4 Data Processing",
    "text": "4 Data Processing\nBefore we start working on our data, we first check for and address the following to ensure that they do not affect subsequent computations and representations\n\nInvalid geometries\nmissing values\n\n\n4.1 Invalid geometires\nWe use the st_is_valid() function from sf to check whether the geometries in nga_wp are valid. We wrap the st_is_valid() using length() function to count the number of invalid geometries returned.\n\nlength(which(st_is_valid(nga_wp) == FALSE))\n\n[1] 0\n\n\nThis is no invalid geometries\n\n\n4.2 Missing values\nWe use the following code chunk to check every row in the nga_wp sf data table to see if there are NA values. If so, to return these records.\n\nnga_wp[rowSums(is.na(nga_wp))!=0,]\n\nSimple feature collection with 13 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 8.553504 ymin: 4.798471 xmax: 14.67882 ymax: 13.71406\nGeodetic CRS:  WGS 84\nFirst 10 features:\n       ADM2_EN ADM2_PCODE ADM1_PCODE ADM0_EN total wpt wpt functional\n3       Abadam   NG008001      NG008 Nigeria         0              0\n86     Bakassi   NG009005      NG009 Nigeria         0              0\n241     Geidam   NG036006      NG036 Nigeria         0              0\n250      Gubio   NG008009      NG008 Nigeria         0              0\n252      Gujba   NG036007      NG036 Nigeria         0              0\n261   Guzamala   NG008010      NG008 Nigeria         0              0\n400       Kaga   NG008014      NG008 Nigeria         0              0\n406 Kala/Balge   NG008015      NG008 Nigeria         0              0\n447     Kukawa   NG008017      NG008 Nigeria         0              0\n473   Madagali   NG002010      NG002 Nigeria         0              0\n    wpt non-functional wpt unknown pct_functional pct_non-functional\n3                    0           0            NaN                NaN\n86                   0           0            NaN                NaN\n241                  0           0            NaN                NaN\n250                  0           0            NaN                NaN\n252                  0           0            NaN                NaN\n261                  0           0            NaN                NaN\n400                  0           0            NaN                NaN\n406                  0           0            NaN                NaN\n447                  0           0            NaN                NaN\n473                  0           0            NaN                NaN\n                          geometry\n3   MULTIPOLYGON (((13.83477 13...\n86  MULTIPOLYGON (((8.580903 4....\n241 MULTIPOLYGON (((12.47754 12...\n250 MULTIPOLYGON (((13.03061 12...\n252 MULTIPOLYGON (((12.33826 11...\n261 MULTIPOLYGON (((13.5701 12....\n400 MULTIPOLYGON (((12.56773 11...\n406 MULTIPOLYGON (((14.58302 11...\n447 MULTIPOLYGON (((14.1372 12....\n473 MULTIPOLYGON (((13.69222 10...\n\n\nThe results show that there are 13 records with missing values, primarily in the pct_functional and pct_non-functional columns. The 13 LGAs have no water point record at all and this resulted in a divisional error (and generating a NaN value) when we compute the the proportion of functional and non-functional water points.\nWe will remove these 13 records with missing values to avoid any unintended computational issue in our analysis downstream with the following code chunk.\n\nnga_wp_processed <- na.omit(nga_wp,c(\"pct_non-functional\"))\n\n\n\n4.3 Transform coordinate system\nWe first check the coordinate system of nga_wp_processed using st_crs() of the sf package.\n\nst_crs(nga_wp_processed)\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n\nWe note that the geometry information is reflected in under WGS 84, a Geographic Coordinate System (GCS) which uses a 3-dimensional spherical surface to define locations on the earth. For our study, we will transform the geometry to Projected Coordinate System which translates GCS data a 2-dimensional surface using st_transform() of the sf package. The Projected Coordinate Systems of Nigeria is EPSG: 26391.\n\nnga_wp_projected <- st_transform(nga_wp_processed, crs=26391)\n\n# check to ascertain if the CRS is correctly projected\nst_crs(nga_wp_projected)\n\nCoordinate Reference System:\n  User input: EPSG:26391 \n  wkt:\nPROJCRS[\"Minna / Nigeria West Belt\",\n    BASEGEOGCRS[\"Minna\",\n        DATUM[\"Minna\",\n            ELLIPSOID[\"Clarke 1880 (RGS)\",6378249.145,293.465,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4263]],\n    CONVERSION[\"Nigeria West Belt\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",4,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",4.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.99975,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",230738.26,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Engineering survey, topographic mapping.\"],\n        AREA[\"Nigeria - onshore west of 6°30'E, onshore and offshore shelf.\"],\n        BBOX[3.57,2.69,13.9,6.5]],\n    ID[\"EPSG\",26391]]\n\n\n\n\n4.4 Checking the distribution of the attribute\nWe note that the % value of non-functional water points are right-skewed by plotting histogram using ggplot.\n\nggplot(data=nga_wp_projected, aes(x= as.numeric(`pct_non-functional`)))+\n  geom_histogram(bins=20,\n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(y='Frequency',x=\"% of non-functional water points\", title = \"Distribution of % of non-functional water points\")\n\n\n\n\n\n\n4.5 Visualise the processed data\nWe have completed the standard pre-processing steps and let’s visualise the data with the following code chuck. We use the jenks method to classify the data points as it optimises class variances to determine the best arrangement off values into different classes\n\n# To set map to interactive \"view\" mode so that we can zoom into to explore the LGAs\ntmap_mode(\"view\")\n\ntmap mode set to interactive viewing\n\ntm_shape(nga_wp_projected) +\n  tm_fill(\"pct_non-functional\", \n          style = \"jenks\", \n          palette = \"Blues\",\n          title = \"% of non-functional wps\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Proportion of non-functional \\nwater points\",\n            main.title.position = \"center\",\n            main.title.size = 1.2)\n\n\n\n\n\n\nWe are now ready to examine spatial patterns of non-functional water points in Nigeria"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1.html#global-spatial-autocorrelation",
    "href": "Take-home_Ex/Take-home_Ex1.html#global-spatial-autocorrelation",
    "title": "Take-home Exercise 1",
    "section": "5 Global Spatial Autocorrelation",
    "text": "5 Global Spatial Autocorrelation\nWe start off by first examining if there is global spatial autocorrelation among LGAs with non-functional water points using the following hypothesis:\nH0: The distribution of non-functional water points is a random phenomenon\nH1: The distribution of non-functional water points is spatially dependent\nWe set the level of significance, α at 0.05\n\n5.1 Select the appropriate Contiguity Spatial Weight for our analysis\nThere are 2 main criterion for defining spatial weights:\n\nContiguity or Adjacency criterion\nDistance criterion:\n\nFixed distance\nAdaptive Distance\n\n\nGiven that we have excluded 13 LGAs with missing values from the data table, applying the contiguity criterion for spatial weights may not be ideal as we have suppressed the number of connections among contiguous LGAs. We generate the Queen contiguity weight matrix using poly2nd() of spdep package below and note that the number of neighbors for the LGAs range from 1 to 14, which is not very consistent.\n\nwm_q = poly2nb(nga_wp_projected,queen=TRUE)\n\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 4348 \nPercentage nonzero weights: 0.750793 \nAverage number of links: 5.713535 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  4  16  57 122 177 137 121  71  39  11   4   1   1 \n4 least connected regions:\n138 509 525 560 with 1 link\n1 most connected region:\n508 with 14 links\n\n\nTo overcome the reservations we have on using the contiguity criterion to determine the spatial weights, one way is to use distance-based criterion and there are 2 schemes available: Fixed Distance and Adaptive Distance\nFor Fixed Distance scheme, while we can make use of dnearneigh() function of spdep package to compute the distance weight matrix distance where all LGAs have at least 1 neighbor, the LGA polygons are of very different sizes and therefore we may generate excessive/limited number of neighbors for some LGAs by using a fixed distance. For instance, bigger regions at the boundaries of the map tend to have fewer neighbors and hence less likely to obtain statistically significant results. To get a sense of how different the LGAs are in terms of land size, we plot the following histogram on the area of the LGAs using st_area() of sf package.\n\nnga_wp_projected$area = st_area(nga_wp_projected)\n\nggplot(data=nga_wp_projected, aes(x= area))+\n  geom_histogram(bins=20,\n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(y='Frequency',x=\"Area\", title = \"Distribution of LGA areas\")\n\n\n\n\nWe also print out the relevant area statistics to show the wide range in land area of the LGAs\n\noptions(scipen=999)\n\nsummary(st_area(nga_wp_projected))\n\n       Min.     1st Qu.      Median        Mean     3rd Qu.        Max. \n    8596599   277850189   696268537  1156093016  1472712805 11250590762 \n\n\nA solution to the concerns for the contiguity and fixed distance criterion is to adopt the Adaptive Distance scheme where we preset a fixed number of k neighbors per LGA. All LGAs are hence connected by the same number of numbers.\nFor this study, we will set k = 8 to strike a balance between not having too high a k value (which may have a smoothening out effect on the values) and being able to obtain statistically-sound results eventually. Setting k = 8 also takes into account that the distribution of the proportion non-functional water points is skewed.\n\n\n5.2 Compute the adaptive distance weight matrix\n\n5.2.1 Derive the centroid of every LGA\nWe need the centroid associated with each LGA before we can work out the neighbor list.\nTo get the longitude values of the centroids, we map the st_centroid() function over the geometry column of our projected sf table and access the longitude value through double bracket notation [[]] and 1.\n\nlongitude <- map_dbl(nga_wp_projected$geometry, ~st_centroid(.x)[[1]])\n\nWe do the same for latitude but access the second value per each centroid with [[2]].\n\nlatitude <- map_dbl(nga_wp_projected$geometry, ~st_centroid(.x)[[2]])\n\nThereafter we combined the longitude and latitude into the same object and review the first few records to check that the coordinates of the centroids are correctly formatted\n\n# Combine the longitude and latitude values into an array object\ncoords = cbind(longitude,latitude)\n\n# Insepct the first few records of the object\nhead(coords)\n\n     longitude latitude\n[1,] 549364.04 123694.9\n[2,] 547123.41 120376.5\n[3,] 489057.42 534262.6\n[4,] 593718.21 113824.1\n[5,] 642618.69 251222.3\n[6,]  84389.95 356433.0\n\n\n\n\n5.2.2 Derive the neighbor list\nWe use the knearneigh() of spdep package to obtain the neighbor list (nb) object for the LGAs, setting k = 8\n\nknn8 <- knn2nb(knearneigh(coords, k=8))\nknn8\n\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 6088 \nPercentage nonzero weights: 1.051248 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\n\n\n5.2.3 Convert the neighbor list object into a spatial weights object\nNext, we use the nb2listw() of spdep package to convert the neighbor list into a spatial weights object.\n\nknn8_lw <- nb2listw(knn8, style = 'B')\n\n# Inspect the spatial weights object\nsummary(knn8_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 6088 \nPercentage nonzero weights: 1.051248 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n  8 \n761 \n761 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 with 8 links\n761 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 with 8 links\n\nWeights style: B \nWeights constants summary:\n    n     nn   S0    S1     S2\nB 761 579121 6088 10950 198564\n\n\n\n\n\n5.3 Run the Moran’s I test\nWe perform the Moran’s I statistical testing using moran.test() of spdep package. The Moran’s I test measures how the proportions of non-functional water points differ in the study area as a whole.\n\nmoran.test(nga_wp_projected$`pct_non-functional`, \n           listw=knn8_lw, \n           zero.policy = TRUE)\n\n\n    Moran I test under randomisation\n\ndata:  nga_wp_projected$`pct_non-functional`  \nweights: knn8_lw    \n\nMoran I statistic standard deviate = 26.388, p-value <\n0.00000000000000022\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.4496039329     -0.0013157895      0.0002919996 \n\n\nThe p-value is <0.05 implying that we can reject the null hypothesis and conclude that the spatial distribution of non-functional water points is not a random phenomenon. The postive Moran’s I statistic of 0.450 indicates that there’s some some degree of clustering of non-functional water points in our study area.\n\n\n5.4 Run the Geary’s C test\nWe perform the Geary’s I statistical testing using geary.test() of spdep package. The Geary’s C test measures how the proportion of the LGA non-functional water points differ from their neighbors.\n\ngeary.test(nga_wp_projected$`pct_non-functional`, \n           listw=knn8_lw, \n           zero.policy = TRUE)\n\n\n    Geary C test under randomisation\n\ndata:  nga_wp_projected$`pct_non-functional` \nweights: knn8_lw \n\nGeary C statistic standard deviate = 25.29, p-value <\n0.00000000000000022\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n     0.5393883718      1.0000000000      0.0003317272 \n\n\nThe Geary’s C statistic is between 0 and 1, indicating that there is clustering and the proportion of non-functional water points between the LGAs and thier neighbors tend to be similar in Nigeria. The p-value is <0.05 implying that the result is statistically significant and we conclude that the spatial distribution of non-functional water points is not a random phenomenon."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1.html#cluster-and-outlier-analysis",
    "href": "Take-home_Ex/Take-home_Ex1.html#cluster-and-outlier-analysis",
    "title": "Take-home Exercise 1",
    "section": "6 Cluster and Outlier Analysis",
    "text": "6 Cluster and Outlier Analysis\nIn this section, we compute the Local Indicators of Spatial Association (“LISA”) statistics to evaluate the existence of clusters and outliers in the spatial arrangement of non-functional water points across Nigeria.\n\n6.1 Compute the local Moran’s I\nThe Local Moran’s I statistic is relatively similar to the Global Moran’s I in that it is providing a measure of how similar locations are to their neighbors. However, the difference is that each LGA receive its own I value, as well as its own variance, z value, expected I, and variance of I\nWe use the localmoran() of spdep package to compute the local Moran’s I.\n\nlocalMI <- localmoran(nga_wp_projected$`pct_non-functional`, knn8_lw)\n\n# Inspect the first few records generated\nhead(localMI)\n\n         Ii         E.Ii   Var.Ii      Z.Ii Pr(z != E(Ii))\n1  5.205163 -0.006635614 4.998981  2.331025    0.019752051\n2  4.755332 -0.004013898 3.024887  2.736483    0.006209989\n3  1.484009 -0.013172741 9.915650  0.475460    0.634459103\n4  6.929392 -0.005959689 4.490148  3.272941    0.001064347\n5  5.129117 -0.008452809 6.366528  2.036134    0.041736858\n6 -1.311319 -0.001416732 1.068001 -1.267515    0.204971134\n\n\nThe column on the far right provides the p-values. We can relate these p-values to different confidence levels (e.g. 99%, 95%, etc.) in order to make a conclusion about the spatial distribution of non-functional water points across the LGAs.\nFor ease of subsequent analysis, we create a sf data table by appending the local Moran’s I dataframe (i.e. localMI) onto nga_wp_projected data table. At the same time, we rename the p-value column for the local Moran’s I to “Pr.li”.\n\nnga_wp_projected.localMI <- cbind(nga_wp_projected,localMI) %>%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\n\n\n6.2 Map the local Moran’s I statistic and the Moran’s I p-value\nUsing choropleth mapping functions of tmap package, we plot 2 maps:\n\nMap 1 representing the local Moran’s I values\nMap 2 representing the local Moran’s I p-values\n\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\n# 1. Map 1 representing the Local Moran's I values\n\nlocalMI.map <- tm_shape(nga_wp_projected.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"Local Moran's I statistics\",\n          palette = \"BrBG\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Map 1: Local Moran's I statistics\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\n# 2. Map representing the local Moran's I p-values\n\npvalue.map <- tm_shape(nga_wp_projected.localMI) +\n  tm_fill(col = \"Pr.Ii\",\n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-BuPu\",\n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Map 2: Local Moran's I p-values\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.26, \n            legend.width = 0.40)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n\n\n6.3 Plot the LISA map\nBefore the plot, we need to first prepare the map classes. The preparatory steps involved are as follow:\n\nCreate a vector to contain the cluster class: quadrant\nDerive the spatially lagged values for proportion of non-functional water points and center them around the mean value using lag.listtw() of spdep package: DV\nCenter the local Moran’s I values around the mean value: LM_I\nSet the level of significance for the local Moran’s I statistic: signif\nDefine and assign the classes based on DV and LM_I values.\n\n[DV <0 & LM_I>0] <- 1 Low-Low\n[DV >0 & LM_I<0] <- 2 Low-High\n[DV <0 & LM_I<0] <- 3 High-Low\n[DV >0 & LM_I>0] <- 4 High-High\n\nAllocate non-significant Moran’s I value to 0\n\n\n# Step 1\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\n\n# Step 2\nnga_wp_projected$`lag_pct_non-functional` <- lag.listw(knn8_lw, nga_wp_projected$`pct_non-functional`)\nDV <- nga_wp_projected$`lag_pct_non-functional` - mean(nga_wp_projected$`lag_pct_non-functional`)     \n\n# Step 3\nLM_I <- localMI[,1] - mean(localMI[,1])   \n\n# Step 4\nsignif <- 0.05       \n\n# Step 5\nquadrant[DV <0 & LM_I>0] <- 1\nquadrant[DV >0 & LM_I<0] <- 2\nquadrant[DV <0 & LM_I<0] <- 3  \nquadrant[DV >0 & LM_I>0] <- 4\n\n# Step 6\nquadrant[localMI[,5]>signif] <- 0\n\nUsing choropleth mapping functions of tmap package, we plot 2 additional maps:\n\nMap 3 representing the Proportion of non-functional water points\nMap 4 representing the LISA map of spatial clusters\n\n\n# Map 3 representing the Proportion of non-functional water points\nnon_functional_wp <- tm_shape(nga_wp_projected) +\n  tm_fill(\"pct_non-functional\", \n          style = \"jenks\", \n          palette = \"Blues\",\n          title = \"% of non-functional wps\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Map 3: Proportion of non-functional \\nwater points\",\n            main.title.position = \"center\",\n            main.title.size = 1.2)\n\n# Map 4 representing the LISA map of spatial clusters\nnga_wp_projected.localMI$quadrant <- quadrant\ncolors <- c(\"#999999\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap <- tm_shape(nga_wp_projected.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = \"Map 4: LISA map of \\nspatial clusters\",\n            main.title.position = \"center\",\n            main.title.size = 1.2)\n\ntmap_arrange(non_functional_wp, LISAmap, \n             asp=1, ncol=2)\n\n\n\n\n\n\n6.4 Interpretation of LISA analysis results\nMap 3 shows the regions with higher proportions of non-function water points were spread throughout the western part of Nigeria, especially in the south-west. The Global Moran’s I and Geary’s C computed in sections 4.3.1 and 4.3.2 respectively confirmed that there’s some degree of clustering of non-functional water points in Nigeria. So this begs the question of where do the clusters of non-functional water points lie. In terms of efforts to review, inspect and repair these faulty water points, it would be more cost effective if we can identify where they are congregated to manage them as a group/cluster.\nMaps 1 and 2, which indicate the local Moran’s I values and p-values indicate that significant clusters appear in the north-east and south-west of the country.\nThe LISA map (Map 4) makes it easier by highlighting the 4 separate high-high clusters (labelled in the enlarged LISA map below) and, attention should be placed on Clusters 1 and 2 given the wider spread of non-functional water points and larger number of LGAs affected.\n\n\n\n\n\nIt is also interesting to note that most low-low clusters are gathered around the north-east part of the country and it maybe worth investigating why the region has lower proportion of water points failures. Most of the low-high and high-low outliers are adjacent to high-high and low-low clusters, which is understandable given that each LGA’s classification is relative to its neighbors. There are pockets of high-low outliers (in orange) spread across the study area. The local administration of these high-low areas should be alerted to their classification as “outliers” and peer-pressured to address the seemingly higher proportion of faulty water points vis-a-vis their neighbors ."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1.html#hot-spot-and-cold-spot-area-analysis",
    "href": "Take-home_Ex/Take-home_Ex1.html#hot-spot-and-cold-spot-area-analysis",
    "title": "Take-home Exercise 1",
    "section": "7 Hot Spot and Cold Spot Area Analysis",
    "text": "7 Hot Spot and Cold Spot Area Analysis\nHot spots refer to regions with attribute values that are higher relative to its surroundings. We will use Getis-Ord’s Gi statistics to detect such spatial anomalies. The method looks at neighbours within a defined proximity to identify where high or low values clutser spatially. Statistically significant hotspots are defined as areas of high values where other areas within the neighbourhood range also share high values too.\nThe analysis consists of three steps:\n\nDerive spatial weight matrix\nCompute Gi statistics\nMap Gi statistics\n\nWe have accomplished Step 1 in Section 4.2 when we derived the adaptive distance weight matrix. Therefore we go next compute the Gi statistics\n\n7.1 Compute Gi statistics using adaptive distance weight matrix\nWe use the localG() of spdep package to drive the local GI statistics and then create a sf data table by appending the local Gi statistics onto nga_wp_projected data table. At the same time, we rename the Gi statistics column to gstat_adaptive.\n\n# Compute the local Gi statistics\ngi.adaptive <- localG(nga_wp_projected$`pct_non-functional`, knn8_lw, zero.policy = FALSE)\n\n\n# Create nga_wp_projected.gi sf data table to store the Gi statistics\nnga_wp_projected.gi <- cbind(nga_wp_projected, as.matrix(gi.adaptive)) %>%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\n7.2 Mark the Gi statistics that are significant\nThe localG() function returns a Z-value and we will check this against the critical value setting the level of significance at 0.05. Based on the documentation for locaG() function, the critical values of the statistic under assumptions given in the references for the 95th percentile are for n=1: 1.645, n=50: 3.083, n=100: 3.289, n=1000: 3.886. For our analysis, we will use the more stringent critical value of 3.886 to define statistical significance. We will create an indicator column in the nga_wp_projected.gi data table for Gi statistics that are significant.\n\ncritial_value <- 3.886\n\nnga_wp_projected.gi = nga_wp_projected.gi %>%\n  mutate(gi_sig_indicator = case_when(\n    abs(gstat_adaptive)> critial_value ~ \"Yes\",\n    abs(gstat_adaptive)<= critial_value ~ \"No\"\n    ))\n\n\n\n7.3 Map Gi values with adaptive distance weights\nWe use the choropleth mapping functions of tmap package, we plot 2 maps:\n\nMap 5 representing the local Gi Z-values\nMap 6 representing areas with significant Gi Z-values\n\n\n# Map 5 representing the Hot and Cold spots using Gi Statistics\nGimap <- tm_shape(nga_wp_projected.gi) +\n  tm_fill(col = \"gstat_adaptive\",\n          style = \"pretty\",\n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5)  +\n  tm_layout(main.title = \"Map 5: Gi values with \\nadaptive distance weights\",\n            main.title.position = \"center\",\n            main.title.size = 1.2)\n\n# Map 6 representing the spots with significant Gi Statistics\nGimap_sig <- tm_shape(nga_wp_projected.gi) +\n  tm_fill(col = \"gi_sig_indicator\",\n          palette = \"-RdGy\",\n          title = \"Significant Gi\") + \n  tm_borders(alpha = 0.5)  +\n  tm_layout(main.title = \"Map 6: LGAs with significant \\nGi Statistic\",\n            main.title.position = \"center\",\n            main.title.size = 1.2)\n\ntmap_arrange(Gimap, Gimap_sig, asp=1, ncol=2)\n\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n7.4 Interpretation of Hot-spot area analysis\nBased on Maps 5 and 6, there are 3 regions of hot-spots and 2 regions of cold-spots that are statistically significant.\n\n\n\n\n\nIn terms of planning and management of repairs, priority can be given to these 3 hot-spot regions given that the proportional of non-functional water points are relative to their neighbors. It is also worth noting that all 3 hot-spots regions are within high-high clusters under the LISA map.\nFor the 2 cold-spot regions, it would be interesting to see if there is any factor which influence the lower proportion of faulty water points and consider if they are relevant to prevent the water point malfuctioning at other LGAs, especially those in the high-high clusters or hotspot regions."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1.html#conclusion",
    "href": "Take-home_Ex/Take-home_Ex1.html#conclusion",
    "title": "Take-home Exercise 1",
    "section": "8 Conclusion",
    "text": "8 Conclusion\nAs illustrated by this case study, geospatial autocorrelation analysis can help water point policy makers, maintenance teams to identify clusters and hot-spots for non-functional water points, plan for and priortise the repairs. On the other hand, a further examination of the outliers and cold-spots could offer insights on how water point failures can be avoided or minimised to provide clean and adequate water supply to the people in Nigeria.\nGeospatial analytics is a useful tool to help organisations and entities optimise the use of their limited resources and make data driven decisions.\n\nReferences\n\nMegan Sim, Analysing and Visualing Spatio-temporal patterns of Covid-19 in DKI Jakarta, Indonesia\nSAS Help Centre, The Moran Scatter Plot, SAS Help Center: The Moran Scatter Plot\nWhat is Hotspot Analysis?, What is Hotspot Analysis? | Geospatiality (glenbambrick.com)"
  }
]